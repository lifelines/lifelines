<!DOCTYPE BOOK PUBLIC "-//OASIS//DTD DocBook V3.1//EN" [
	<!entity llversion	"3.0.5">    
]>	
	
<BOOK ID="DOCBOOK">
  <?dbhtml filename="ll-doc.htm">
  <BOOKINFO>
	
	
<!--

    $Id$
     
    This is lifelines.sgml. 

    Marc Nozell <marc@nozell.com>  26-Jul-2001
    - Changed <simpara> to <para>.  Newer docbook likes it better.
    
    Marc Nozell <marc@nozell.com>  21-Sep-2000
    - updated license info
    - point to lifelines.sourceforge.net
    - change references from lines302 to llines
    - make most lines less than 80 characters wide

                                                       -->
<!-- ================================================= -->
	
    <TITLE>

<APPLICATION>LifeLines</APPLICATION> Documentation
</TITLE>
    
    <AUTHORGROUP>
      <AUTHOR>
	<FIRSTNAME>Thomas T. </FIRSTNAME>
	<SURNAME>Wetmore </SURNAME>
	<LINEAGE>IV</LINEAGE>
      </AUTHOR>
    </AUTHORGROUP>
    
    <SUBTITLE><APPLICATION>LifeLines</APPLICATION> Version &llversion</SUBTITLE>
  </BOOKINFO>
  
  <CHAPTER>
    
    <TITLE>

Users' Manual

</TITLE>
    
    <SECT1>
      
      
      <TITLE>

INTRODUCTION

</TITLE>
      
      
      
<PARA>

	<APPLICATION>LifeLines</APPLICATION> is a genealogy program
	that runs on <ACRONYM>UNIX</ACRONYM> systems. It maintains
	genealogical records (persons, families, sources, events and
	others) in a database, and generates reports from those
	records. There are no practical limits on the number of
	records that can be stored in a
	<APPLICATION>LifeLines</APPLICATION> database, nor on the
	amounts or kinds of data that can be kept in the
	records. <APPLICATION>LifeLines</APPLICATION> does not contain
	built-in reports.  Instead it provides a programming subsystem
	that you use to program your own reports and charts. The
	programming subsystem also lets you query your databases and
	process your data in any
	way. <APPLICATION>LifeLines</APPLICATION> uses the terminal
	independent features of <ACRONYM>UNIX</ACRONYM> to provide a
	screen and menu based user interface.

</PARA>



<PARA>

	<APPLICATION>LifeLines</APPLICATION> is a non-commercial,
	experimental system that is use at your own risk software. I
	developed <APPLICATION>LifeLines</APPLICATION> for personal
	use and shared it with friends. Enough of a demand arose
	through word of mouth and internet, that I have made the
	<APPLICATION>LifeLines</APPLICATION> source code and other
	information freely available under an MIT-style license
	reproduced below:

</PARA>

<PARA>
	<quote>
Copyright (c) 1991-1999 Thomas T. Wetmore IV

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

	</quote>

</PARA>

<PARA>

	The source code, documentation and a collection of report
	scripts are located at <ULINK
	URL="http://lifelines.sourceforge.net/">
	http://lifelines.sourceforge.net/</ULINK>.  You can also find
	binary kits for some platforms.  If you are a developer and
	wish to contribute enhancements, please sign up on sourceforge
	and contact <ULINK URL="mailto:marc@nozell.com"> Marc
	Nozell</ULINK> who is currently managing the project.
	</PARA>

	<NOTE>
	<PARA>
	Prior to 1999, Lifelines was available on the ftp sites,
	<ULINK URL="ftp://ftp.cac.psu.edu">ftp.cac.psu.edu</ULINK> and
	<ULINK URL="ftp://hoth.stsci.edu">hoth.stsci.edu</ULINK>.
	Please use sourceforge instead.
	</PARA>
	</NOTE>




</SECT1>



<SECT1>



<TITLE>

INSTALLATION

</TITLE>



<PARA>

	You may be installing <APPLICATION>LifeLines</APPLICATION>
	from a source distribution package or as an executable program
	already prepared for your <ACRONYM>UNIX</ACRONYM> system. The
	source distribution comes with the readme, build script and
	make files necessary to build
	<APPLICATION>LifeLines</APPLICATION>. Follow the instructions
	in the readme file. The executable program will be named
	<COMMAND>llines</COMMAND>. <COMMAND>llines</COMMAND> is the
	<APPLICATION>LifeLines</APPLICATION> program; put it in a
	directory in your execution path. If you get the program in
	executable form, follow whatever instructions came with it.
	The source distribution package also contains documentation
	and some <APPLICATION>LifeLines</APPLICATION> programs.

</PARA>



</SECT1>



<SECT1>



<TITLE>

STARTING <APPLICATION>LIFELINES</APPLICATION> AND CREATING DATABASES

</TITLE>



<PARA>

	You normally start <APPLICATION>LifeLines</APPLICATION> with
	the command: <USERINPUT><COMMAND>lines</COMMAND> <REPLACEABLE
	CLASS="PARAMETER">database</REPLACEABLE></USERINPUT> where
	database is the name of a <APPLICATION>LifeLines</APPLICATION>
	database. If <APPLICATION>LifeLines</APPLICATION> finds the
	database, <APPLICATION>LifeLines</APPLICATION> opens the
	database and takes you to the program's main menu. If the
	database doesn't exist, <APPLICATION>LifeLines</APPLICATION>
	asks whether it should create it, and if you answer yes, does
	so. You may create any number of databases, but only one can
	be accessed by <APPLICATION>LifeLines</APPLICATION> at a
	time. If you built the <APPLICATION>LifeLines</APPLICATION>
	executable from the source package, the executable may be
	named <COMMAND>llines</COMMAND> rather than
	<COMMAND>lines</COMMAND>. You may either change its name or
	invoke <APPLICATION>LifeLines</APPLICATION> by using the
	command <COMMAND>llines</COMMAND> instead.

</PARA>



<PARA>

	The full command line interface to
	<APPLICATION>LifeLines</APPLICATION> is:
	
	<SYNOPSIS>
	   <COMMAND>lines</COMMAND> <OPTION>[-rwfkam]</OPTION><REPLACEABLE CLASS="PARAMETER">[database]</REPLACEABLE>
	</SYNOPSIS>

</PARA>



<PARA>

	The options mean the following:
	<GLOSSLIST><GLOSSENTRY><GLOSSTERM>-r</GLOSSTERM><GLOSSDEF>

<PARA>

	open database with read only access

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM>-w</GLOSSTERM><GLOSSDEF>

<PARA>

	open database with writeable access

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM>-f</GLOSSTERM><GLOSSDEF>

<PARA>

	force open the database - use only in emergency

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM>-a</GLOSSTERM><GLOSSDEF>

<PARA>

	log dynamic memory operation (for debugging)

</PARA>

</GLOSSDEF></GLOSSENTRY></GLOSSLIST>

</PARA>



<PARA>

	The <OPTION>-r</OPTION> option opens the database with read
	only access. When in this mode
	<APPLICATION>LifeLines</APPLICATION> will not let you modify
	the database; no other operations are affected. The
	<OPTION>-w</OPTION> option opens the database with writeable
	access. If the database cannot be opened with the requested
	mode <APPLICATION>LifeLines</APPLICATION> quits
	immediately. When you open a database with neither the
	<OPTION>-r</OPTION> or <OPTION>-w</OPTION> options,
	<APPLICATION>LifeLines</APPLICATION> first tries to open the
	database with writeable access; if not possible
	<APPLICATION>LifeLines</APPLICATION> then tries to open the
	database with read-only access; and if this is not possible
	<APPLICATION>LifeLines</APPLICATION> quits. A
	<APPLICATION>LifeLines</APPLICATION> database may be open
	simultaneously by any number of programs with read-only
	access; however, if a database is open by a program with
	writeable access, then it cannot be opened by any other other
	program.

</PARA>



<PARA>

	In rare situations the read/write mode mechanism can fail;
	when this happens a database may appear unopenable. If this
	happens use the <OPTION>-f</OPTION> option to force open the
	database; this will open the database and reset the mode
	mechanism. This is a dangerous feature; you can use it to open
	the same database with writeable access more than once; the
	results are unpredictable and generally disasterous.

</PARA>



<PARA>

	If you don't give the name of a database on the command line,
	<APPLICATION>LifeLines</APPLICATION> will prompt you for
	it. If you do not use the <ENVAR>LLDATABASES</ENVAR> shell
	variable (described later), the name you enter must be the
	name of a <APPLICATION>LifeLines</APPLICATION> database
	directory expressed using normal <ACRONYM>UNIX</ACRONYM>
	absolute or relative path naming. If you do use the
	<ENVAR>LLDATABASES</ENVAR> variable,
	<APPLICATION>LifeLines</APPLICATION> will search for the
	database in the directories named in the variable; this can be
	very convenient.

</PARA>



</SECT1>



<SECT1>



<TITLE>

INTRODUCTION TO <ACRONYM>GEDCOM</ACRONYM>

</TITLE>



<PARA>

	<APPLICATION>LifeLines</APPLICATION> records are stored in
	<ACRONYM>GEDCOM</ACRONYM> format; you organize, edit and
	maintain your data in this format. <ACRONYM>GEDCOM</ACRONYM>
	is a standard that defines a file format for moving
	genealogical data between computer
	systems. <APPLICATION>LifeLines</APPLICATION> has adopted this
	format for structuring the records in its databases. This
	approach provides a structured yet flexible method for storing
	all the data you wish to record. There are few restrictions on
	the format, amount or type of information you may store in a
	<APPLICATION>LifeLines</APPLICATION> database.

</PARA>



<PARA>

	<ACRONYM>GEDCOM</ACRONYM> is defined at two levels. At the
	syntactic level <ACRONYM>GEDCOM</ACRONYM> is a simple set of
	rules for organizing and structuring data into records, with
	no concern about the types of records, types or formats of
	information in the records, or the relationships between
	records. At the semantic level <ACRONYM>GEDCOM</ACRONYM> adds
	an additional set of rules that specify what record types are
	allowed, how records must be structured, how data within the
	records must be identified and formatted, and what specific
	relationships between the record types are allowed. In
	principle there can be multiple semantic versions of
	<ACRONYM>GEDCOM</ACRONYM>, though in practice there is only
	one, lineage-linked <ACRONYM>GEDCOM</ACRONYM>. Unfortunately
	this semantic version of <ACRONYM>GEDCOM</ACRONYM> is poorly
	defined, and every genealogical system has interpreted it in
	different ways.

</PARA>



<PARA>

	<APPLICATION>LifeLines</APPLICATION> uses
	<ACRONYM>GEDCOM</ACRONYM> primarily at the syntactic level,
	though it does impose a few of the generally accepted
	lineage-linked semantic restrictions. This means some
	important things. It means that you can store all your
	genealogical data in your <APPLICATION>LifeLines</APPLICATION>
	database, and that you have wide freedom in how you choose
	your own conventions for structuring and formatting your
	data. But it also means that the way you store data in your
	databases can be different from the way that someone else
	stores their data.  This can be a problem if you share data
	with others or share report programs with other
	<APPLICATION>LifeLines</APPLICATION> users. My recommendation
	is to use <ACRONYM>GEDCOM</ACRONYM> lineage-linking
	conventions wherever possible.

</PARA>



<PARA>

	<APPLICATION>LifeLines</APPLICATION> does not use forms or
	screens to guide you through entering or changing
	data. Instead you use a screen editor and directly edit the
	data records. This requires you to understand the
	<ACRONYM>GEDCOM</ACRONYM> format, and be able to edit data in
	<ACRONYM>GEDCOM</ACRONYM> format, before you can use
	<APPLICATION>LifeLines</APPLICATION>. The
	<ACRONYM>GEDCOM</ACRONYM> format is quite simple; this
	introduction will provide all you need to know about
	<ACRONYM>GEDCOM</ACRONYM> in order to use
	<APPLICATION>LifeLines</APPLICATION>.

</PARA>



<PARA>

	Here is an example <ACRONYM>GEDCOM</ACRONYM> person record:

<EXAMPLE>

<TITLE>

 <ACRONYM>GEDCOM</ACRONYM> person record

</TITLE>

<PROGRAMLISTING ROLE="gedcom">
  0 @I25@ INDI
  1 NAME <USERINPUT>Thomas Trask /Wetmore/ Sr</USERINPUT>
  1 SEX <USERINPUT>M</USERINPUT>
  1 BIRT
    2 DATE <USERINPUT>13 March 1866</USERINPUT>
    2 PLAC <USERINPUT>St. Mary's Bay, Digby, Nova Scotia</USERINPUT>
    2 SOUR <USERINPUT>Social Security application</USERINPUT>
  1 NATU
    2 NAME <USERINPUT>Thomas T. Wetmore</USERINPUT>
    2 DATE <USERINPUT>26 October 1888</USERINPUT>
    2 PLAC <USERINPUT>Norwich, New London, Connecticut</USERINPUT>
    2 AGE <USERINPUT>22 years</USERINPUT>
    2 COUR <USERINPUT>New London County Court of Common Pleas</USERINPUT>
    2 SOUR <USERINPUT>court record from National Archives</USERINPUT>
  1 OCCU <USERINPUT>Antiques Dealer</USERINPUT>
  1 DEAT
    2 NAME <USERINPUT>Thomas Trask Wetmore</USERINPUT>
    2 DATE <USERINPUT>17 February 1947</USERINPUT>
    2 PLAC <USERINPUT>New London, New London, Connecticut</USERINPUT>
    2 AGE <USERINPUT>80 years, 11 months, 4 days</USERINPUT>
    2 CAUS <USERINPUT>Heart Attack</USERINPUT>
    2 SOUR <USERINPUT>New London Death Records</USERINPUT>
  1 FAMC @F11@
  1 FAMS @F6@
  1 FAMS @F12@

</PROGRAMLISTING></EXAMPLE>

</PARA>



<PARA>

	A <ACRONYM>GEDCOM</ACRONYM> record is made up of lines. Each
	line has a level number and a tag, and most lines have a value
	following the tag. The first line in every record has a
	cross-reference index between the level number and the tag.

</PARA>



<PARA>

	Level numbers allow data to be structured to any degree of
	detail; lines with higher level numbers expand on lines with
	lower numbers. Each record begins at level 0, and each deeper
	level increments the level by
	one. <APPLICATION>LifeLines</APPLICATION> does not restrict
	the structuring depth. Tags are uppercase (by convention) code
	words that specify the kind of information on the line or on
	the higher numbered lines that follow. The information after
	the tag, if any, is the value of the line.

</PARA>



<PARA>

	The first line in a record indicates its type. There are four
	fixed record types in <APPLICATION>LifeLines</APPLICATION>
	databases: person, family, source and event. The first, 0
	level line in these records have tags
	<STRUCTNAME>INDI</STRUCTNAME>, <STRUCTNAME>FAM</STRUCTNAME>,
	<STRUCTNAME>SOUR</STRUCTNAME> and
	<STRUCTNAME>EVEN</STRUCTNAME>, respectively. Besides these
	record types, you may create your own record types by using
	any other tag on the 0 level line of a record. The lines that
	begin records are the only level 0 lines used in
	<APPLICATION>LifeLines</APPLICATION>. Each level 0 line has a
	cross-reference index between the level number and the
	tag. This index is the record's internal reference key; other
	records may refer to this record by using this index.
	Cross-reference indexes are bracketed by @ characters.

</PARA>



<PARA>

	The first line in the example record has the
	<STRUCTNAME>INDI</STRUCTNAME> tag, identifying it as a
	person. The cross-reference index value, I25, can be used by
	other records to refer to this record.

</PARA>



<PARA>

	The second line in the example has the person's name. Each
	person record in a <APPLICATION>LifeLines</APPLICATION>
	database must have at least one <STRUCTFIELD>1
	NAME</STRUCTFIELD> line, and its value must be in
	<ACRONYM>GEDCOM</ACRONYM> name format. This format allows
	names to be as long as needed, but the surname, which may be
	placed anywhere in the name, must be separated from the rest
	of the name by one or two slashes. For example:

<EXAMPLE>

<TITLE>
Example of NAME formats

</TITLE>

<PROGRAMLISTING>
1 NAME <USERINPUT>John/Smith</USERINPUT>
1 NAME <USERINPUT>John /Smith/</USERINPUT>
1 NAME <USERINPUT>John/Smith/Jr.</USERINPUT>
</PROGRAMLISTING>
</EXAMPLE>

</PARA>



<PARA>

	The second slash is required only if name elements follow the
	surname. White space is optional before the first slash and
	after the second. If you don't know a person's surname, or the
	person doesn't have a surname, you may use / or // or no
	slashes at all. For example:

<EXAMPLE>

<TITLE>
Example of searching on NAMEs
</TITLE>

<PROGRAMLISTING>

1 NAME <USERINPUT>Mary//</USERINPUT>
1 NAME <USERINPUT>Mary/</USERINPUT>
1 NAME <USERINPUT>Mary</USERINPUT>
</PROGRAMLISTING>

</EXAMPLE>

	are all ways to enter a person named Mary with no known
	surname. A person may have any number, including zero, given
	names and/or initials. A <APPLICATION>LifeLines</APPLICATION>
	person record may have any number of <STRUCTFIELD>1
	NAME</STRUCTFIELD> lines, though the person will be displayed
	with the first name value only. Persons are indexed under all
	their names, however, so you will be able to search for
	persons by any of their names.
</PARA>



<PARA>

	The next line in the example gives the person's
	sex. <APPLICATION>LifeLines</APPLICATION> doesn't require a
	<STRUCTFIELD>1 SEX</STRUCTFIELD> line, but you should include
	it. The value of the line should be <USERINPUT>M</USERINPUT>
	or <USERINPUT>F</USERINPUT> if the sex is known; it can be
	left blank or set to <USERINPUT>U</USERINPUT> or
	<USERINPUT>?</USERINPUT>, say, if not known. A person must
	have a <STRUCTFIELD>1 SEX</STRUCTFIELD> line with a value of
	either <USERINPUT>M</USERINPUT> or <USERINPUT>F</USERINPUT>
	before he or she can be made a spouse or parent in a family.

</PARA>



<PARA>

	The example record also contains three events: birth,
	naturalization, and death. An event begins with a level 1 line
	whose tag indicates the event type. For example,
	<STRUCTFIELD>BIRT</STRUCTFIELD> is the tag for a birth event.
	
</PARA>



<PARA>

	Events usually have at least a <STRUCTFIELD>2
	DATE</STRUCTFIELD> and a <STRUCTFIELD>2 PLAC</STRUCTFIELD>
	line and often a <STRUCTFIELD>2 SOUR</STRUCTFIELD> line. The
	<STRUCTFIELD>DATE</STRUCTFIELD> and
	<STRUCTFIELD>PLAC</STRUCTFIELD> lines give the date and place
	of the event. The value of a
	<APPLICATION>LifeLines</APPLICATION>
	<STRUCTFIELD>DATE</STRUCTFIELD> line is free format, though
	<APPLICATION>LifeLines</APPLICATION> will try to parse it for
	specific day, month and year information. The value of a
	<STRUCTFIELD>PLAC</STRUCTFIELD> line is usually a
	comma-separated list of geopolitical units, starting with the
	most specific, ending with the most general. The
	<STRUCTFIELD>SOUR</STRUCTFIELD> line indicates the source of
	information about the event. The
	<STRUCTFIELD>SOUR</STRUCTFIELD> line can be the root of a full
	description of the source, or the value of the
	<STRUCTFIELD>SOUR</STRUCTFIELD> line can be a cross-reference
	key that refers to the source record that describes the
	source.

</PARA>



<PARA>

	The naturalization event (with tag
	<STRUCTFIELD>NATU</STRUCTFIELD>) shows a few other lines. The
	<STRUCTFIELD>2 NAME</STRUCTFIELD> line gives the person's name
	as recorded in the source (only <STRUCTFIELD>1
	NAME</STRUCTFIELD> lines must follow <ACRONYM>GEDCOM</ACRONYM>
	format). The <STRUCTFIELD>2 AGE</STRUCTFIELD> line gives the
	person's age at the time of the event. The <STRUCTFIELD>2
	COUR</STRUCTFIELD> line indicates the court where
	naturalization occurred.

</PARA>



<PARA>

	The final event is a death event (tag
	<STRUCTFIELD>DEAT</STRUCTFIELD>). The <STRUCTFIELD>2
	CAUS</STRUCTFIELD> line gives the cause of death.

</PARA>



<PARA>

	At the end of the record are three lines that refer to family
	records. A <STRUCTFIELD>1 FAMC</STRUCTFIELD> line refers to a
	family record that the person belongs to as a child; its value
	is the cross-reference index value of that family.  A
	<STRUCTFIELD>1 FAMS</STRUCTFIELD> line refers to a family
	record that the person belongs to as a spouse or parent.

</PARA>



<PARA>

	When using <APPLICATION>LifeLines</APPLICATION> to edit a
	person, you will not be able to edit the cross reference
	values on the <STRUCTFIELD>0 INDI</STRUCTFIELD>,
	<STRUCTFIELD>1 FAMC</STRUCTFIELD> or <STRUCTFIELD>1
	FAMS</STRUCTFIELD> lines; these are maintained by
	<APPLICATION>LifeLines</APPLICATION>.

</PARA>



<PARA>

	Here is an example family record:

<EXAMPLE>

<TITLE>
Example family record
</TITLE>

<PROGRAMLISTING>

  0 @F6@ FAM
  1 HUSB @I25@
  1 WIFE @I26@
  1 MARR
    2 DATE <USERINPUT>31 March 1891</USERINPUT>
    2 PLAC <USERINPUT>New London, New London, Connecticut</USERINPUT>
    2 SOUR <USERINPUT>New London Vital Records</USERINPUT>
  1 CHIL @I27@
  1 CHIL @I17@</PROGRAMLISTING></EXAMPLE>

</PARA>



<PARA>

	The <STRUCTFIELD>0 FAM</STRUCTFIELD> line assigns the family
	the cross-reference index of F6. The record contains
	<STRUCTFIELD>1 HUSB</STRUCTFIELD> and <STRUCTFIELD>1
	WIFE</STRUCTFIELD> lines that refer to the two
	spouses/parents. The record also holds a marriage event (tag
	<STRUCTFIELD>MARR</STRUCTFIELD>) and two <STRUCTFIELD>1
	CHIL</STRUCTFIELD> lines that refer to two children in the
	family. When editing family records, you cannot edit the
	<STRUCTFIELD>0 FAM</STRUCTFIELD>, <STRUCTFIELD>1
	HUSB</STRUCTFIELD>, <STRUCTFIELD>1 WIFE</STRUCTFIELD>, or
	<STRUCTFIELD>1 CHIL</STRUCTFIELD> lines; these are maintained
	by <APPLICATION>LifeLines</APPLICATION>.

</PARA>

<PARA>

	When you create new records for your database, you are free to
	invent tags and structure your data in any way you see
	fit. However, it is good practice to use standard
	<ACRONYM>GEDCOM</ACRONYM> tags and value formats.
	<APPLICATION>LifeLines</APPLICATION> does enforce a small set
	of conventions that you must obey. Within person records,
	<APPLICATION>LifeLines</APPLICATION> requires that you use
	<STRUCTFIELD>1 NAME</STRUCTFIELD> and <STRUCTFIELD>1
	SEX</STRUCTFIELD> lines with their special meanings and value
	formats. Though not required,
	<APPLICATION>LifeLines</APPLICATION> assumes that you will use
	<STRUCTFIELD>1 BIRT</STRUCTFIELD>, <STRUCTFIELD>1
	DEAT</STRUCTFIELD>, <STRUCTFIELD>1 CHR</STRUCTFIELD>, and
	<STRUCTFIELD>1 BURI</STRUCTFIELD> lines for birth, death,
	baptism and burial events, respectively. In family records,
	<APPLICATION>LifeLines</APPLICATION> assumes you will use the
	<STRUCTFIELD>1 MARR</STRUCTFIELD> event for marriage
	events. Within person records, you are not allowed to use
	<STRUCTFIELD>0 INDI</STRUCTFIELD>, <STRUCTFIELD>1
	FAMC</STRUCTFIELD> or <STRUCTFIELD>1 FAMS</STRUCTFIELD> lines,
	since these are used to maintain linkage information. Within
	family records, you are not allowed to use <STRUCTFIELD>0
	FAM</STRUCTFIELD>, <STRUCTFIELD>1 HUSB</STRUCTFIELD>,
	<STRUCTFIELD>1 WIFE</STRUCTFIELD> or <STRUCTFIELD>1
	CHIL</STRUCTFIELD> lines.

</PARA>



<PARA>

	The indentation shown in the examples is not part of
	<ACRONYM>GEDCOM</ACRONYM> format. When
	<APPLICATION>LifeLines</APPLICATION> prepares records for you
	to edit, however, it always indents the records, making them
	easier to read and understand. You do not need to follow this
	indentation scheme when you edit the records. Indentation is
	removed from the data before it is stored in the database.

</PARA>



</SECT1>



<SECT1>



<TITLE>

MAIN MENU

</TITLE>



<PARA>

	After <APPLICATION>LifeLines</APPLICATION> opens an existing
	database, or creates a new one, it presents you with the main
	menu:
	
<SCREEN>
Please choose an operation:
   b Browse the persons in the database
   s Search database
   a Add information to the database
   d Delete information from the database
   p Pick a report from list and run
   r Generate reports from the database
   t Modify character translation tables
   u Miscellaneous utilities
   x Handle source, event and other records
   q Quit and return to UNIX
</SCREEN>


</PARA>

<PARA>

	Select an operation by striking the proper selection letter.

</PARA>



<PARA>

	The browse operation lets you browse the database and perform
	many operations on the data. The search operation provides some
	simple wildcard search capabilities, which lead into browsing
	particular records. The add operation lets you add
	new information, and the delete operation removes
	information. The report operations read report
	programs and generates output reports. The modify character
	translation tables operation changes the translation
	tables. The miscellaneous utilities operation provides such
	things as backup and restore. The handle source, event and
	other records operation gives you access to these three record
	types. The quit operation closes the database and returns to
	<ACRONYM>UNIX</ACRONYM>.

</PARA>



<PARA>

	The browse operation deserves special mention, because it
	provides a rich environment for searching, viewing, adding,
	modifying, merging and deleting information in the
	database. You will find that you operate from the browsing
	modes most of the time. The operations are all described in
	later sections.

</PARA>



</SECT1>



<SECT1>



<TITLE>

ENTERING THE FIRST PERSON

</TITLE>



<PARA>

	Normally you add persons to the database from the browsing
	modes, but when entering the first person there is no one in
	the database to browse to. To add the first person to a
	<APPLICATION>LifeLines</APPLICATION> database, first select
	the add operation from the main menu. You will be prompted
	with the add menu (described later).  Strike p to add a
	person. <APPLICATION>LifeLines</APPLICATION> creates a
	template of a <ACRONYM>GEDCOM</ACRONYM> person record, and
	puts you in a screen editor to edit the template. The default
	template is:

<EXAMPLE>
<TITLE>
Default person record template
</TITLE>

<PROGRAMLISTING>

  0 INDI
  1 NAME <REPLACEABLE>Fname /Surname/</REPLACEABLE>
  1 SEX <REPLACEABLE>MF</REPLACEABLE>
  1 BIRT
    2 DATE
    2 PLAC
    2 SOUR
  1 DEAT
    2 DATE
    2 PLAC
    2 SOUR</PROGRAMLISTING></EXAMPLE>

</PARA>



<PARA>

	Edit the template to create the new person's record. Change
	the name to the person's name. Assign the person's sex by
	deleting either <USERINPUT>M</USERINPUT> or
	<USERINPUT>F</USERINPUT>. Fill out the birth and death events
	as best you can. If the person is alive, remove the death
	event. Remove any <STRUCTFIELD>DATE</STRUCTFIELD> and
	<STRUCTFIELD>PLAC</STRUCTFIELD> lines you do not have the
	information for.

</PARA>



<PARA>

	The default template provides lines for one birth and one
	death event. You can expand the record with other events (even
	more birth or death events) and lines. Indentation makes it
	easier to read and edit the record, but isn't necessary. You
	may change the default edit template by defining the user
	option <OPTION>INDIREC</OPTION> (described later).

</PARA>



<PARA>

	Here is how I might edit the template when creating a record
	about myself:

<EXAMPLE>

<TITLE>
Example editing of template record
</TITLE>

<PROGRAMLISTING>

  0 INDI
  1 NAME <USERINPUT>Thomas Trask /Wetmore/ IV</USERINPUT>
  1 SEX <USERINPUT>M</USERINPUT>
  1 BIRT
    2 DATE <USERINPUT>18 December 1949</USERINPUT>
    2 PLAC <USERINPUT>New London, New London, Connecticut</USERINPUT>
    2 SOUR <USERINPUT>Birth Certificate</USERINPUT>
  1 OCCU <USERINPUT>Software Engineer</USERINPUT>
  1 RESI
    2 DATE <USERINPUT>1982 to 1995</USERINPUT>
    2 PLAC <USERINPUT>Newburyport, Essex, Massachusetts</USERINPUT>
    2 ADDR <USERINPUT>2 Barton Street, Newburyport, MA 01950</USERINPUT>
	
... lots of other events and facts
</PROGRAMLISTING>
</EXAMPLE>

</PARA>



<PARA>

	When you edit a person record, don't add or modify
	<STRUCTFIELD>INDI</STRUCTFIELD>,
	<STRUCTFIELD>FAMC</STRUCTFIELD> or
	<STRUCTFIELD>FAMS</STRUCTFIELD>
	lines. <APPLICATION>LifeLines</APPLICATION> creates and
	maintains these lines through specific user commands.

</PARA>



<PARA>

	When you finish editing and leave the editor, you
	automatically return to
	<APPLICATION>LifeLines</APPLICATION>. If you made an error
	(eg, didn't use proper level numbers or didn't follow the
	proper name convention), <APPLICATION>LifeLines</APPLICATION>
	displays an error message, and asks if you want to re-edit the
	record. If you don't, <APPLICATION>LifeLines</APPLICATION>
	doesn't add the person to the database.

</PARA>



<PARA>

	When the record is in proper format,
	<APPLICATION>LifeLines</APPLICATION> asks if you are sure you
	want to add the person to the database. If you answer yes, the
	person is added; if you answer no, the person isn't. In both
	cases <APPLICATION>LifeLines</APPLICATION> returns to the main
	menu.

</PARA>



</SECT1>



<SECT1>



<TITLE>

SCREEN EDITORS AND ENVIRONMENT VARIABLES

</TITLE>



<PARA>

	With <APPLICATION>LifeLines</APPLICATION> you maintain the
	database records using a screen editor. This is different than
	other genealogical programs where screens or forms are used to
	gather the data.The default screen editor for
	<APPLICATION>LifeLines</APPLICATION> is
	<APPLICATION>vi</APPLICATION>. (The DOS/Windows version defaults
	instead to notepad.exe.) This can be overridden by the
	<ENVAR>ED</ENVAR>, <ENVAR>EDITOR</ENVAR> or
	<ENVAR>LLEDITOR</ENVAR> environment variables. For example, if
	you prefer the emacs screen editor, and if you use a bourne-compatible
	shell, you may add the line:
	<USERINPUT><ENVAR>ED</ENVAR>=<REPLACEABLE>emacs</REPLACEABLE></USERINPUT>
	to your login profile file, and
	<APPLICATION>LifeLines</APPLICATION> will use
	<APPLICATION>emacs</APPLICATION> for editing.

</PARA>



<PARA>

	There are five other, <APPLICATION>LifeLines</APPLICATION>
	specific environment variables. They are
	<ENVAR>LLDATABASES</ENVAR>, <ENVAR>LLARCHIVES</ENVAR>,
	<ENVAR>LLPROGRAMS</ENVAR>, <ENVAR>LLREPORTS</ENVAR>,
	and <ENVAR>LLNEWDBDIR</ENVAR>. <ENVAR>LLDATABASES</ENVAR> and
	<ENVAR>LLPROGRAMS</ENVAR> are <ACRONYM>UNIX</ACRONYM> path
	list variables. (<ENVAR>LLNEWDBDIR</ENVAR> was added in version
	3.0.6.)

</PARA>

<PARA>
	As of version 3.0.6, there is also a configuration file, and
	entries in it may be used in lieu of environment variables.
	It is ordinarily named .linesrc under UNIX, and lines.cfg under
	DOS/Windows. A sample configuration file should have been
	included in the distribution. 
</PARA>



<PARA>

	<ENVAR>LLDATABASES</ENVAR> can be set to a list of directories
	that hold <APPLICATION>LifeLines</APPLICATION> databases. When
	you execute the <APPLICATION>LifeLines</APPLICATION> program,
	these directories will be searched in turn for the database
	mentioned on the command line. For example,
	<USERINPUT><ENVAR>LLDATABASES</ENVAR>=<REPLACEABLE>.:/home/ttw4/LifeLines/Databases</REPLACEABLE></USERINPUT>
	indicates that databases should be searched for in the current
	directory first, and if not found there, then searched for in:
	<FILENAME>/usr/ttw4/LifeLines/Databases</FILENAME>

</PARA>



<PARA>

	Each <APPLICATION>LifeLines</APPLICATION> database is
	implemented as a directory with specific contents. The
	<ENVAR>LLDATABASES</ENVAR> variable should be set to a list of
	directories that contain these database directories, not to a
	list of database directories themselves.

</PARA>



<PARA>

	The environment variable <ENVAR>LLPROGRAMS</ENVAR> is used in
	the same way, but to specify the search path for
	<APPLICATION>LifeLines</APPLICATION> report generating and
	other programs (described later).

</PARA>



<PARA>

	<ENVAR>LLARCHIVES</ENVAR> and <ENVAR>LLREPORTS</ENVAR> can
	each be set to specify a single
	directory. <ENVAR>LLARCHIVES</ENVAR> is used to select a
	directory where all database backup files will be stored, and
	<ENVAR>LLREPORTS</ENVAR> is used to select a directory where
	all generated reports and program outputs will be placed.

</PARA>

<PARA>

	<ENVAR>LLNEWDBDIR</ENVAR> may be set to specific a single 
	directory - new databases without paths will be created in this
	location if given. This is of course a convenience for users 
	who generally put all their databases under a single common
	directory.

</PARA>

<PARA>

	You are not required to use these environment variables; when
	a variable is not defined,
	<APPLICATION>LifeLines</APPLICATION> uses the current
	directory as its default value. If you do use the variables,
	you can override their use by specifying files and directories
	as either absolute or relative paths.

</PARA>

<PARA>

	With version 3.0.6 or later, you may use the configuration file in
	lieu of environment variables. This is especially oriented towards
	users on MS-Windows systems, on which environment variables are not
	as common a configuration technique.

</PARA>


<PARA>

	<APPLICATION>LifeLines</APPLICATION> uses the curses library
	for terminal independent I/O. This requires you to specify
	your terminal type with the <ENVAR>TERM</ENVAR> environment
	variable. (This is not relevant in the DOS/Windows version.)

</PARA>



</SECT1>



<SECT1>



<TITLE>

BASICS OF BROWSING

</TITLE>



<PARA>

	You will use the browsing screens of
	<APPLICATION>LifeLines</APPLICATION> most of the time. When in
	these modes you can quickly search for or browse through the
	persons and families in the database. When you find a person
	or family you are interested in, you can then edit their
	records.

</PARA>



<PARA>
	The browsing screens also allow you to add new persons and
	families to the database, add spouses to families, add
	children to families, swap the order of spouses and children,
	merge persons and merge families, and perform other
	operations. The browsing screens also lets you remove spouses
	from families and remove children from families.
</PARA>

<PARA>
	There are six browsing screens. The person and family screens 
	concentrate on a single person and family, respectively. The
	list screen allows you to browse through a list of persons. The
	person tandem screen shows two persons at once, and the family
	tandem screen shows two families at once. The auxiliary screen
	is used browsing any other type of records (e.g., events, 
	sources, notes). (The auxiliary screen is new with version 3.0.6.)

</PARA>

<PARA>
	Beginning with version 3.0.6, each browsing screen has multiple
	view modes. The view mode affects how the information is displayed
	on the screen, but does not affect the menu choices available at
	the bottom of the screen. Menu commands are available on each screen
	to change amongst the view modes available for that screen.
</PARA>

<PARA>
	The person screen has the most view modes. It has normal mode, 
	which shows a summary of the vital records of the person. It (like
	all other screens) has GEDCOM mode, which shows the actual GEDCOM
	data of the record, and also expanded GEDCOM mode, which shows the
	actual GEDCOM data, but augments it with information on each line
	that contains a cross-reference (GEDCOM xref). It has two pedigree
	or tree modes, one showing an ancestral tree and one showing a 
	descendant tree. The depth of the pedigree trees shown may be 
	adjusted via menu commands.
</PARA>

<PARA>
	The tandem person screen has the same modes as the person screen.
</PARA>

<PARA>
	The family screen and tandem family screen alike have normal mode
	(showing a summary of vitals), GEDCOM mode, and expanded GEDCOM
	mode. 
</PARA>

<PARA>
	The auxiliary screen has only GEDCOM mode and expanded GEDCOM mode.
	(The list screen has no view modes at present).
</PARA>

</SECT1>



<SECT1>



<TITLE>

IDENTIFYING A PERSON OR LIST OF PERSONS TO BROWSE

</TITLE>



<PARA>

	To enter the browsing modes from the main menu strike
	b. <APPLICATION>LifeLines</APPLICATION> asks you to identify a
	person or list of persons to browse to:
	
<SCREEN>
Please identify person or persons to browse to.
Enter name, key, refn or list:
</SCREEN>

</PARA>

<PARA>

	Enter either a name or partial name, or an internal key value,
	or a user-defined reference key (described later) or the name
	of a previously defined list of persons (described later), and
	strike return.

</PARA>



<PARA>

	<APPLICATION>LifeLines</APPLICATION> allows wide flexibility
	in how to enter names. You may enter a name in upper or lower
	case or any combination. You may leave out all but the first
	given name, and, for given names, you may leave out any
	letters except the first. You may leave vowels out of the
	surname, and after four or five consonants have been typed,
	you may leave them out too. You must separate the given names
	from the surname by a slash, and if you enter given names
	after the surname (as in Chinese names), or any modifiers
	(such as Jr, Sr, IV, etc.), they must be separated from the
	surname by another slash. Here are a few of the ways I can
	enter my name:

<EXAMPLE>

<TITLE>
Example of entering a name
</TITLE>

<LITERALLAYOUT>
Thomas Trask /Wetmore/ IV
thomas/wetmore/iv
t t/wetmr/i
th tr/Wetmore
t/wtmr/iv
</LITERALLAYOUT>
</EXAMPLE>

</PARA>



<PARA>

	You may browse to the list of all persons with the same
	surname by using the * character as the first initial. For
	example:

<EXAMPLE>

<TITLE>
Example of using wildcard in browsing
</TITLE>

	<LITERALLAYOUT>*/wetmore</LITERALLAYOUT></EXAMPLE>matches all
	persons with surname Wetmore. This is the only wildcard
	feature supported in browsing. (However, the search operation,
	new with version 3.0.6, provides some simple wildcards for
	finding individual name fragments, or searching by user-defined
	reference keys.)

</PARA>



<PARA>

	After you enter a name, <APPLICATION>LifeLines</APPLICATION>
	searches for all persons who match. There are three
	possibilities: no one matches; one person matches; or more
	than one person matches. In the first case
	<APPLICATION>LifeLines</APPLICATION> writes: <SCREEN>There is
	no one in the database with that name.</SCREEN> and leaves you
	in the main menu.

</PARA>



<PARA>

	If one person matches, <APPLICATION>LifeLines</APPLICATION>
	enters the person browse mode displaying the matched
	person. If more than one person matches,
	<APPLICATION>LifeLines</APPLICATION> enters the list browsing
	mode with the list of matching persons.

</PARA>



<PARA>

	You may also identify a person by entering his or her
	internal, cross-reference key value. The internal key values
	of all person records are an I followed by digits. In the
	current version, when you enter a key value you must omit the
	I. If <APPLICATION>LifeLines</APPLICATION> finds a person with
	the key value you provide,
	<APPLICATION>LifeLines</APPLICATION> enters the person
	browsing mode displaying that person.

</PARA>



<PARA>

	The browse command b is also available from most browsing
	modes. The command works the same way from those modes as it
	does from the main menu.

</PARA>



</SECT1>



<SECT1>



<TITLE>

ZIP IDENTIFYING A NEW PERSON

</TITLE>



<PARA>

	Some <APPLICATION>LifeLines</APPLICATION> operations need you
	to identify a person, not for the purpose of browsing, but for
	the purpose of completing an operation you have requested. For
	example, when you add a child to a family,
	<APPLICATION>LifeLines</APPLICATION> may ask you to identify
	the child. When this happens a panel pops up that asks you to
	identify a person. You respond by typing a name or key exactly
	as you would for the b command. If no one matches,
	<APPLICATION>LifeLines</APPLICATION> returns to the previous
	browsing mode. If the name matches persons in the database
	<APPLICATION>LifeLines</APPLICATION> displays something like:
	
<SCREEN>
Please choose from among these persons.
  >Thomas Trask Wetmore, b. 1826, N.B. (42)
   Thomas Trask Wetmore IV, b. 1949, Conn. (1)
   Thomas Trask Wetmore III, b. 1925, Conn. (6)
   Thomas Trask Wetmore Jr, b. 1896, Conn. (11)
   Thomas Trask Wetmore Sr, b. 1866, N.S. (23)
   Thomas Trask Wetmore V, b. 1982, Mass. (5)
_______________________________________________
Commands: j Move down k Move up i Select q Quit
</SCREEN>


</PARA>



<PARA>

	Use the j and k commands to move the selection cursor (>) to
	the correct person, and then use the i command to select that
	person. There may be more persons in the list than you can see
	at once. If this is so then you can use the j and k commands
	to scroll through the full list. If you don't find the proper
	person, use the q command and
	<APPLICATION>LifeLines</APPLICATION> asks whether you want to
	enter another name.

</PARA>

<PARA>

	When <APPLICATION>LifeLines</APPLICATION> creates a list of
	names for you to select from, it tries to add extra
	information to the name; this helps determine which name to
	choose, and is important in databases where many persons have
	the same name. <APPLICATION>LifeLines</APPLICATION> also
	places the person's key value at the end of each menu line;
	this may be helpful in large databases.

</PARA>



<PARA>

	Some browse screens provide the z command, which allows you to
	browse to a new person using the zip style of identification
	rather than the b style.

</PARA>



</SECT1>



<SECT1>



<TITLE>

BROWSE DISPLAY BASICS

</TITLE>



<PARA>

	The screen display for each browsing screen is made up of
	panels. At the bottom of each display is a message panel used
	for one line messages. Each display contains one or two data
	panels showing information from the database. And each display
	has a panel with the operation menu available for that screen.

</PARA>



</SECT1>



<SECT1>



<TITLE>

PERSON BROWSE SCREEN

</TITLE>



<PARA>

	After you identify a person to browse to,
	<APPLICATION>LifeLines</APPLICATION> enters the person browse
	screen. The top panel in the display gives basic information
	about the person (in the normal, or vitals, mode, which is the 
	default). The middle panel provides a menu of commands.
	For example:

<SCREEN>
person: Thomas Trask WETMORE Sr (25)
  born: 13 March 1866, St. Mary's Bay, Digby, Nova Scotia
  died: 17 February 1947, New London, New London, Connecticut
  father: Daniel Lorenzo WETMORE, b. 1821, N.S., d. 1903, Conn. (48)
  mother: Mary Ann DOTY, b. 1824, N.S., d. 1897, Conn. (59)
  spouse: Margaret Ellen KANEEN, b. 1855, Eng., d. 1900, Conn. (26)
    child: Portia Louise WETMORE, b. 1892, Conn., d. 1921, Conn. (27)
    child: Thomas Trask WETMORE, b. 1896, Conn., d. 1970, Conn. (17)
  spouse: Arleen M KEENEY, m. 1914, Conn. (75)
_______________________________________________________________________
Please choose an operation:             (pg 1/3)
  e  Edit the person       g  Browse to family    p  Show pedigree
  f  Browse to father      u  Browse to parents   n  Create new person
  m  Browse to mother      b  Browse to persons   a  Create new family
  s  Browse to spouse/s    h  Add as spouse       x  Swap two families
  c  Browse to children    i  Add as child        tt Enter tandem mode
  o  Browse to older sib   r  Remove as spouse    ?  Other menu choices
  y  Browse to younger sib d  Remove as child     q  Return to main menu
_______________________________________________________________________
LifeLines -- Person Browse Screen
</SCREEN>


</PARA>



<PARA>

The commands perform a wide variety of functions.

</PARA>



<PARA>

<GLOSSLIST><GLOSSENTRY><GLOSSTERM><KEYCAP>e</KEYCAP> <ACTION>Edit the person. </ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Edit the person's database
	record. <APPLICATION>LifeLines</APPLICATION> puts the record
	in a file, and then runs a screen editor so you can edit the
	record. When you return from the editor,
	<APPLICATION>LifeLines</APPLICATION> asks you to confirm any
	changes; the person is changed only if you answer yes.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>f</KEYCAP> <ACTION>Browse to father.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Browse to the person's father. If the father isn't in the
	database, <APPLICATION>LifeLines</APPLICATION> doesn't change
	the display. If there are more than one father,
	<APPLICATION>LifeLines</APPLICATION> asks you to select one.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>m</KEYCAP> <ACTION>Browse to mother.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Browse to the person's mother. If the mother isn't in the
	database, <APPLICATION>LifeLines</APPLICATION> doesn't change
	the display. If there are more than one mother,
	<APPLICATION>LifeLines</APPLICATION> asks you to select one.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>s</KEYCAP> <ACTION>Browse to spouse/s.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Browse to the person's spouse. If the person has more than one
	spouse, <APPLICATION>LifeLines</APPLICATION> asks you to
	select one. If the person has no spouse, the display does not
	change.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>c</KEYCAP> <ACTION>Browse to children.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Browse to one of the person's children. If there is more than
	one child, <APPLICATION>LifeLines</APPLICATION> asks you to
	select one. If the person has no children, the display does
	not change.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>o</KEYCAP> <ACTION>Browse to older sib.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Browse to the person's next older sibling. If the person has
	no such sibling, the display does not change. Only siblings
	from the same family are browsed by this command.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>y</KEYCAP> <ACTION>Browse to younger sib.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Browse to the person's next younger sibling. If the person has
	no such sibling, the display does not change. Only siblings
	from the same family are browsed by this command.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>g</KEYCAP> <ACTION>Browse to family.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Browse to the family the person is a spouse or parent in, and
	switch to the family browse mode. If the person is in more
	than one family, <APPLICATION>LifeLines</APPLICATION> asks you
	to identify which one. If the person is not a spouse or parent
	in any family, the display does not change.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>u</KEYCAP> <ACTION>Browse to parents.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Browse to the family the person is a child in, and switch to
	the family browse mode. If the person is not a child in a
	family, the display does not change. If the person is a child
	in more than one family, <APPLICATION>LifeLines</APPLICATION>
	asks you to identify which one.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>b</KEYCAP> <ACTION>Browse to persons.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Browse to a new person or list of
	persons. <APPLICATION>LifeLines</APPLICATION> asks you to
	identify a person or persons by name, key or list name, and
	depending on how many persons are identified, switches either
	to the list browse mode, or remains in the person browse mode.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>h</KEYCAP> <ACTION>Add as spouse.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Add the person as a spouse/parent to an existing
	family. <APPLICATION>LifeLines</APPLICATION> asks you to
	identify the family, and then asks you to confirm the request.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>i</KEYCAP> <ACTION>Add as child.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Add the person as a child to an existing family. The person
	may already be a child in another
	family. <APPLICATION>LifeLines</APPLICATION> asks you to
	identify the family, and then asks you to confirm the request.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>r</KEYCAP> <ACTION>Remove as spouse.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Remove the person as a spouse or parent from an existing
	family. If the person is a spouse or parent in more than one
	family, <APPLICATION>LifeLines</APPLICATION> asks you to
	identify the family.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>d</KEYCAP> <ACTION>Remove as child.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

Remove the person as a child in an existing family.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>p</KEYCAP> <ACTION>Show pedigree.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Change to pedigree browse mode. The person becomes the root
	person in the pedigree display.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>n</KEYCAP> <ACTION>Create new person.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Create and add a new person to the
	database. <APPLICATION>LifeLines</APPLICATION> creates a
	record template and puts you into the screen editor to edit
	the record. When you return from the editor,
	<APPLICATION>LifeLines</APPLICATION> asks you to confirm the
	operation. If you do, the new person is added and becomes the
	current person. If not, the new person is not added, and
	<APPLICATION>LifeLines</APPLICATION> returns to the original
	display.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>a</KEYCAP> <ACTION>Create new family.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Create and add a new family to the database. The new family
	may have the current person as either a spouse/parent or as a
	child; <APPLICATION>LifeLines</APPLICATION> asks which. If you
	choose to create a family with the person as a spouse/parent,
	<APPLICATION>LifeLines</APPLICATION> asks you to identify the
	other spouse if he or she is known. In either case
	<APPLICATION>LifeLines</APPLICATION> creates a family
	template, and places you in the screen editor.  When you
	return from the editor, <APPLICATION>LifeLines</APPLICATION>
	asks you to confirm the operation. If you do,
	<APPLICATION>LifeLines</APPLICATION> adds the family and
	shifts into family browse mode. If the command you ran just
	before the a command were the n command, and you choose to
	create a family with the person as a spouse/parent,
	<APPLICATION>LifeLines</APPLICATION> guesses that the other
	spouse in the family will be the person displayed just before
	the new person was
	created. <APPLICATION>LifeLines</APPLICATION> asks you if this
	is the case, and if so, automatically make that person the
	other spouse in the new family. If this is not the case,
	<APPLICATION>LifeLines</APPLICATION> asks you to identify the
	other spouse.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>x</KEYCAP> <ACTION>Swap two families.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Swap (change chronological order) any two families that the
	person belongs to as a spouse or
	parent. <APPLICATION>LifeLines</APPLICATION> asks you to
	identify the two families and then swaps them.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>t</KEYCAP> <ACTION>Enter tandem mode.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Change to the tandem person browse
	mode. <APPLICATION>LifeLines</APPLICATION> first asks you to
	identify the second person.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>?</KEYCAP> <ACTION>Other menu choices.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>
	Go to the next page of menu choices. This will have no effect on the 
	upper (data) portion of the screen, but it allows you to page through
	all available commands for this display screen.
</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>q</KEYCAP> <ACTION>Return to main menu.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Return to the <APPLICATION>LifeLines</APPLICATION> main menu.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>z</KEYCAP> <ACTION>Zip browse to person.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

        Zip browse to a new person.
	<APPLICATION>LifeLines</APPLICATION> asks you to
        identify a person by name or key value, and if you do so,
        browses to that person.

</PARA>


</GLOSSDEF></GLOSSENTRY></GLOSSLIST>

</PARA>



</SECT1>

<SECT1>

<TITLE>

LIST BROWSE SCREEN

</TITLE>



<PARA>

	This browse screen handles lists of persons. The top panel shows
	information about one person in the list.  The left panel
	shows a list of up to 12 persons. The person shown in the top
	panel is identified by the > character. The right panel is the
	menu of available commands.
	
<SCREEN>
person: Thomas Trask WETMORE Sr (25)
  born: 13 March 1866, St. Mary's Bay, Digby, Nova Scotia
  died: 17 February 1947, New London, New London, Connecticut
  father: Daniel Lorenzo WETMORE, b. 1821, N.S., d. 1903, Conn. (48)
  mother: Mary Ann DOTY, b. 1824, N.S., d. 1897, Conn. (59)
  spouse: Margaret Ellen KANEEN, b. 1855, Eng., d. 1900, Conn. (26)
_______________________________________________________________________
  Thomas Trask WETMORE (42)                Choose an operation:
  Thomas Trask WETMORE III (6)              j Move down list
  Thomas Trask WETMORE IV (1)               k Move up list
  Thomas Trask WETMORE (11)                 e Edit this person
 >Thomas Trask WETMORE Sr (23)              i Browse this person
  Thomas Trask WETMORE (5)                  m Mark this person
                                            d Delete from list
                                            t Enter tandem mode
                                            n Name this list
                                            b Browse new persons
                                            a Add to this list
                                            x Swap mark/current
                                            q Return to main menu
_______________________________________________________________________
LifeLines -- List Browse Screen
</SCREEN>


</PARA>



<PARA>

<GLOSSLIST><GLOSSENTRY><GLOSSTERM><KEYCAP>j</KEYCAP> <ACTION>Move down list.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Move down the list one person. The list panel is only large
	enough to show 12 persons. However, the list may contain many
	more persons. Use the <KEYCAP>j</KEYCAP> and
	<KEYCAP>k</KEYCAP> commands to scroll to these other persons.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>k</KEYCAP> <ACTION>Move up list.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Move up the list one person. The list panel is only large
	enough to show 12 persons. However, the list may contain many
	more persons. Use the <KEYCAP>j</KEYCAP> and
	<KEYCAP>k</KEYCAP> commands to scroll to these other persons.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>e</KEYCAP> <ACTION>Edit this person.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Edit the displayed person's database
	record. <APPLICATION>LifeLines</APPLICATION> runs the editor
	on the person's record. When you return from the editor,
	<APPLICATION>LifeLines</APPLICATION> asks you to confirm any
	changes, and then leaves you in the list browse screen.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>i</KEYCAP> <ACTION>Browse this person.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Change to the person browse screen with the current person.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>m</KEYCAP> <ACTION>Mark this person.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Mark the current person if he/she is not marked; unmark the
	person is he/she is.  The marked person is shown with an x by
	his/her name. Marked persons are used by the t and x
	commands. Only one person may be marked at a time.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>d</KEYCAP> <ACTION>Delete from list.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Remove the current person from the browse list (not from the database).

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>t</KEYCAP> <ACTION>Enter tandem mode.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Change to the tandem person mode with the current person and
	the marked person as the two persons. If no person is marked there is no change.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>n</KEYCAP> <ACTION>Name this list.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Lists of persons may be named, allowing you to quickly browse
	back to them by giving a list name in response to the b
	command from different
	modes. <APPLICATION>LifeLines</APPLICATION> will prompt you
	for the name. List names are most convenient when short.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>b</KEYCAP> <ACTION>Browse new persons.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Browse to a new person or list of persons. You can identify a
	person or list of persons by name, internal or user key or by
	list name.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>a</KEYCAP> <ACTION>Add to this list.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Add more persons to the current browse
	list. <APPLICATION>LifeLines</APPLICATION> asks you to
	identify a new person or list of persons by name, key or list
	name, and they are added to and name-sorted into the current
	list.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>x</KEYCAP> <ACTION>Swap mark/current.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Swap the current person with the marked person in the list.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>q</KEYCAP> <ACTION>Return to main menu.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Return to the <APPLICATION>LifeLines</APPLICATION> main menu.

</PARA>

</GLOSSDEF></GLOSSENTRY></GLOSSLIST>

</PARA>



</SECT1>



<SECT1>



<TITLE>

FAMILY BROWSE SCREEN

</TITLE>



<PARA>

	This browse screen displays information about a family. The top
	panel shows basic information about the family. The bottom
	panel shows the menu of available commands.
	
<SCREEN>
father: Thomas Trask WETMORE IV (1)
  born: 18 December 1949, New London, New London, Connecticut
  died:
mother: Luann Frances GRENDA (2)
  born: 10 July 1949, Pittsburgh, Allegheny, Pennsylvania
  died:
married: 1 August 1970, Governors Island, New York, New York
  child: Anna Vivian Wetmore, b. 1974, Alaska (3)
  child: Marie Margaret WETMORE, b. 1979, Conn. (4)
  child: Thomas Trask WETMORE V, b. 1982, Mass. (5)
_______________________________________________________________________
Please enter the next family browse operation
  e Edit the family     s Add spouse to family  t Enter family tandem
  f Browse to father    a Add child to family   b Browse to new persons
  m Browse to mother    r Remove spouse from    z Browse to new person
  c Browse to children  d Remove child from     q Return to main menu
  n Create new person   x Swap two children
_______________________________________________________________________
LifeLines - Family Browse Screen</SCREEN>

</PARA>



<PARA>

<GLOSSLIST><GLOSSENTRY><GLOSSTERM><KEYCAP>e</KEYCAP> <ACTION>Edit the family.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Edit the family's record. <APPLICATION>LifeLines</APPLICATION>
	writes the record to a file and puts you into an editor to
	edit the file. When you return from the editor,
	<APPLICATION>LifeLines</APPLICATION> asks you to confirm the
	update; the family is changed only if you do so.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>f</KEYCAP> <ACTION>Browse to father.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Browse to the father/husband of the family, switching to
	person browse screen. If the father is not there, there is no change.

</PARA>

</GLOSSDEF>
	  </GLOSSENTRY>

<GLOSSENTRY><GLOSSTERM><KEYCAP>m</KEYCAP><ACTION>Browse to mother.</ACTION>
	    </GLOSSTERM>
	
	<GLOSSDEF>

<PARA>

	Browse to the mother/wife of the family, switching to person
	browse screen. If the mother is not there, there is no change.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>c</KEYCAP> <ACTION>Browse to children.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Browse to a child in the family, switching to the person
	browse screen. If the family has more than one child,
	<APPLICATION>LifeLines</APPLICATION> asks you to identify a
	specific child.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>n</KEYCAP> <ACTION>Create new person.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Create and add a new person to the
	database. <APPLICATION>LifeLines</APPLICATION> creates a
	record template and puts you into the screen editor to edit
	the record. When you return from the editor,
	<APPLICATION>LifeLines</APPLICATION> asks you to confirm the
	operation. If you do, the new person is added to the
	database. If not, the new person is not added. In both cases
	the display does not change.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>s</KEYCAP> <ACTION>Add spouse to family.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Add a spouse to the
	family. <APPLICATION>LifeLines</APPLICATION> asks you to
	identify the new spouse. If the command you ran just before
	the s command were the n command,
	<APPLICATION>LifeLines</APPLICATION> guesses that the new
	spouse will be the person just
	created. <APPLICATION>LifeLines</APPLICATION> asks if this is
	the case, and if so, makes that person the second spouse in
	the family. If not, <APPLICATION>LifeLines</APPLICATION> asks
	you to identify the other spouse.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>a</KEYCAP> <ACTION>Add child to family.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Add a child to the
	family. <APPLICATION>LifeLines</APPLICATION> asks you to
	identify the new child. If the command you ran just before the
	a command were the n command,
	<APPLICATION>LifeLines</APPLICATION> guesses that the new
	child will be the person just
	created. <APPLICATION>LifeLines</APPLICATION> asks if this is
	the case, and if so, adds that child to the family. If not,
	<APPLICATION>LifeLines</APPLICATION> asks you to identify the
	child. If the family already has children,
	<APPLICATION>LifeLines</APPLICATION> also asks where to place
	the new child in the family.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>r</KEYCAP> <ACTION>Remove spouse from.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Remove a parent/spouse from the
	family. <APPLICATION>LifeLines</APPLICATION> asks you to
	identify the person, and if you do, removes him or her. The
	person is not removed from the database.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>d</KEYCAP> <ACTION>Remove child from.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Remove a child from the
	family. <APPLICATION>LifeLines</APPLICATION> asks you to
	identify the child should, and if you do, removes the child
	from the family. The person is not removed from the database.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>x</KEYCAP> <ACTION>Swap two children.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Swap (change the chronological order) of any two children in
	the family.  <APPLICATION>LifeLines</APPLICATION> asks you to
	identify the two children and then swaps them.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>t</KEYCAP> <ACTION>Enter family tandem.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	This command takes you to the tandem family browse
	screen. <APPLICATION>LifeLines</APPLICATION> asks you to
	identify a second family, and then takes you to the tandem
	family screen, displaying both the two families.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>b</KEYCAP> <ACTION>Browse to persons.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Browse to a new person or list of persons. You can identify a
	person or list by name, by key, or by list name. If you
	successfully identify a new person or persons you will switch
	into the person or list browse screens.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>z</KEYCAP> <ACTION>Browse to person.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Zip browse to a new person.
	<APPLICATION>LifeLines</APPLICATION> asks you to identify a
	person by name or key value, and if you do, browses to that
	person.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>q</KEYCAP> <ACTION>Return to main menu.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Return to the <APPLICATION>LifeLines</APPLICATION> main menu.

</PARA>

</GLOSSDEF></GLOSSENTRY></GLOSSLIST>

</PARA>



</SECT1>



<SECT1>



<TITLE>

TANDEM PERSON BROWSE MODE

</TITLE>



<PARA>

	The tandem person browse screen displays information about two
	persons. Its main use it to support the person merging
	operation. The top two panels show two persons in the format
	used in the person and list screen displays. The bottom panel
	gives the menu of available commands. For example:


<SCREEN>
  person: Thomas Trask WETMORE Sr (25)
  born: 13 March 1866, St. Mary's Bay, Digby, Nova Scotia
  died: 17 February 1947, New London, New London, Connecticut
  father: Daniel Lorenzo WETMORE, b. 1821, N.S., d. 1903, Conn. (48)
  mother: Mary Ann DOTY, b. 1824, N.S., d. 1897, Conn. (59)
  spouse: Margaret Ellen KANEEN, b. 1855, Eng., d. 1900, Conn. (26)
______________________________________________________________________
person: Thomas Trask WETMORE IV (1)
  born: 18 December 1949, New London, New London, Connecticut
  died:
  father: Thomas Trask WETMORE III, b. 1925, Conn. (6)
  mother: Joan Marie HANCOCK, b. 1928, Conn. (7)
  spouse: Luann Frances GRENDA, m. 1970, N.Y. (2)
______________________________________________________________________
Please choose an operation:
 e Edit top person    s Browse top spouse/s   a Add family
 t Browse to top      c Browse top children   j Merge bottom to top
 f Browse top father  b Browse to persons     x Switch top/bottom
 m Browse top mother  d Copy top to bottom    q Return to main menu
______________________________________________________________________
LifeLines - Two Person Browse Screen
</SCREEN>


</PARA>



<PARA>

<GLOSSLIST><GLOSSENTRY><GLOSSTERM><KEYCAP>e</KEYCAP> <ACTION>Edit top person.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Edit the top person's
	record. <APPLICATION>LifeLines</APPLICATION> writes the record
	to a file, and puts you in the screen editor to edit the
	file. When you return from the editor,
	<APPLICATION>LifeLines</APPLICATION> asks you to confirm the
	update; the person is changed only if you do so.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>t</KEYCAP> <ACTION>Browse to top.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Switch to the person display with the top person as current person.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>f</KEYCAP> <ACTION>Browse top father.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Replace the top person with his/her father.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>m</KEYCAP> <ACTION>Browse top mother.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Replace the top person with his/her mother.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>s</KEYCAP> <ACTION>Browse top spouse/s.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Replace the the top person with his/her spouse. If the person
	has more than one spouse, <APPLICATION>LifeLines</APPLICATION>
	asks you to identify one.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>c</KEYCAP> <ACTION>Browse top children.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

Replace the top person with one of his/her children. If the person has more
than one child, <APPLICATION>LifeLines</APPLICATION> asks you to identify the one.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>b</KEYCAP> <ACTION>Browse to persons.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

Browse to a new person or list of persons. <APPLICATION>LifeLines</APPLICATION> asks you to identify a new
person or persons by name, key or list name, and then does as described in the section on identifying a
person.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>d</KEYCAP> <ACTION>Copy top to bottom.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

Copy the top person into the bottom person. A new person is not created; the same
person is displayed twice.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>a</KEYCAP> <ACTION>Add family.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

Create a new family record; <APPLICATION>LifeLines</APPLICATION> assumes the two displayed persons are to become
the spouses/parents in the new family; they must be of opposite sex.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>j</KEYCAP> <ACTION>Merge bottom to top.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

Merge the bottom person into the top person. <APPLICATION>LifeLines</APPLICATION> combines the two person
records and places you in the screen editor to edit the combined record. When you are done, if you
confirm the operation, <APPLICATION>LifeLines</APPLICATION> removes the bottom person from the database, and the top person is
given the combined record. See the section on merging.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>x</KEYCAP> <ACTION>Switch top/bottom.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

Swap the two persons in the display.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>q</KEYCAP> <ACTION>Return to main menu.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

Return to the <APPLICATION>LifeLines</APPLICATION> main menu.

</PARA>

</GLOSSDEF></GLOSSENTRY></GLOSSLIST>

</PARA>



</SECT1>



<SECT1>



<TITLE>

TANDEM FAMILY BROWSE MODE

</TITLE>



<PARA>

The tandem family browse screen displays information about two families. Its main use it to support the
family merging operation.The top two panels provide information about the two families you are
browsing, and the bottom panel holds the menu of available commands. For example:
<SCREEN>
father: Thomas Trask WETMORE IV (1)
  born: 18 December 1949, New London, New London, Connecticut
mother: Luann Frances GRENDA (2)
  born: 10 July 1949, Pittsburgh, Allegheny, Pennsylvania
married: 1 August 1970, Governors Island, New York, New York
  child: Anna Vivian WETMORE, b. 1974, Alaska (3)
__________________________________________________________________
father: Thomas Trask WETMORE III (6)
  born: 26 October 1925, New London, New London, Connecticut
wife: Joan Marie Hancock (7)
  born: 6 June 1928, New London, New London, Connecticut
married: 5 February 1949, New London, New London, Connecticut
  child: Thomas Trask WETMORE IV, b. 1949, Conn. (1)
__________________________________________________________________
Please choose an operation:
 e Edit top family   f Browse to fathers  j Merge bottom to top
 t Browse to top     m Browse to mothers  q Return to main menu
 b Browse to bottom  x Switch top/bottom
__________________________________________________________________
LifeLines - Two Family Browse Mode
</SCREEN>


</PARA>



<PARA>

<GLOSSLIST><GLOSSENTRY><GLOSSTERM><KEYCAP>e</KEYCAP> <ACTION>Edit top family.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

This command lets you edit the top family's record. <APPLICATION>LifeLines</APPLICATION> writes the record into
a file, and then puts you into an editor to edit that information. When you return from the editor,
<APPLICATION>LifeLines</APPLICATION> asks you whether you are sure you want to update the family in the database. The family
is changed only if you answer yes.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>t</KEYCAP> <ACTION>Browse to top.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

Change to the family browse screen with the top family the current family.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>b</KEYCAP> <ACTION>Browse to bottom.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

Change to the single family browse screen with the bottom family the current
family.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>f</KEYCAP> <ACTION>Browse to fathers.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

Change to the tandem person screen with the fathers of the two
families as the two persons.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>m</KEYCAP> <ACTION>Browse to mothers.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

Change to the tandem person screen with the mothers of the two
families as the two persons.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>x</KEYCAP> <ACTION>Switch top/bottom.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

Swap the two families in the display.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>j</KEYCAP> <ACTION>Merge bottom to top.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

Merge the bottom family into the top family. <APPLICATION>LifeLines</APPLICATION> combines the two
family records and places you in the screen editor to edit the combined record. When you are done, if
you confirm the operation, <APPLICATION>LifeLines</APPLICATION> deletes the bottom family from the database, and the top
family is given the combined record. See the section on merging.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>q</KEYCAP> <ACTION>Return to main menu.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

Return to the <APPLICATION>LifeLines</APPLICATION> main menu.

</PARA>

</GLOSSDEF></GLOSSENTRY></GLOSSLIST>

</PARA>



</SECT1>



<SECT1>



<TITLE>

PEDIGREE BROWSE MODE

</TITLE>



<PARA>

The pedigree browse screen displays a four-generation pedigree for the current person. The top panel
holds the pedigree, and the bottom panel holds the menu of available commands. For example:
<SCREEN>
                  John WETMORE [1755-1848] (32)
            Daniel Van Cott WETMORE [1791-1881] (41)
                  Anna VAN COTT [1757-1802] (33)
      Daniel Lorenzo WETMORE [1821-1903] (48)
                  Thomas TRASK [-1836] (81)
            Hannah TRASK [1797-1829] (46)
                  Susannah PORTER [1754-] (82)
Thomas Trask WETMORE Sr [1866-1947] (25)
                  Samuel DOTY [1759-] (501)
            Samuel DOTY [1787-] (74)
                  Hephzibah PORTER [1764-1853] (502)
      Mary Ann DOTY [1827-1897] (59)
                  Nathan SAVERY [1748-1826] (510)
            Lydia SAVERY [1806-] (75)
                  Deidamia SABEAN [1765-1845] (511)
__________________________________________________________________
Please choose an operation:
 e Edit the person   m Browse to mother    g Browse to family
 i Browse to person  s Browse to spouse/s  b Browse to persons
 f Browse to father  c Browse to children  q Return to main menu
__________________________________________________________________
LifeLines - Pedigree Browse Mode</SCREEN>

</PARA>



<PARA>

<GLOSSLIST><GLOSSENTRY><GLOSSTERM><KEYCAP>e</KEYCAP> <ACTION>Edit the person.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

Edit the current person.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>i</KEYCAP> <ACTION>Browse to person.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

Change to the person display mode with the current person.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>f</KEYCAP> <ACTION>Browse to father.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

Browse to the father of the current person, shifting the pedigree one
generation back. If the father is not in the database, there is no change.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>m</KEYCAP> <ACTION>Browse to mother.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

Browse to the mother of the current person, shifting the pedigree one
generation back. If the mother is not in the database, there is no change.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>s</KEYCAP> <ACTION>Browse to spouse/s.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

Browse to a spouse of the current person, shifting the display to the pedigree of
that person. If the current person has more than one spouse, <APPLICATION>LifeLines</APPLICATION> asks you to identify the spouse;
if the person has no spouse there is no change.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>c</KEYCAP> <ACTION>Browse to children.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

Browse to a child of the current person, shifting the pedigree one generation
forward. If the current person has more than one child, <APPLICATION>LifeLines</APPLICATION> asks you to identify the child; if
the person has no children there is no change.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>g</KEYCAP> <ACTION>Browse to family.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

Change to the family display; the family will be the one that the current person
belongs to as spouse or parent. If there are more than one, <APPLICATION>LifeLines</APPLICATION> asks you to identify the proper
one.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>b</KEYCAP> <ACTION>Browse to persons.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

Browse to another person or list of persons; if you identify a single person the
display remains in the pedigree display; if you identify more than one person the display changes to
the list browse mode.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>q</KEYCAP> <ACTION>Return to main menu.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

Leave the pedigree browsing mode and return to the main menu.

</PARA>

</GLOSSDEF></GLOSSENTRY></GLOSSLIST>

</PARA>



</SECT1>



<SECT1>



<TITLE>

ADD OPERATION

</TITLE>



<PARA>

If you choose the add operation from the main menu, <APPLICATION>LifeLines</APPLICATION> displays the add menu:
<SCREEN>
What do you want to add?
  p Person - add new person to the database
  f Family - create family record from one or two spouses
  c Child - add a child to an existing family
  s Spouse - add a spouse to an existing family
  q Quit - return to the previous menu
</SCREEN>


</PARA>



<PARA>

These operations work in a straightforward way. <APPLICATION>LifeLines</APPLICATION> asks you the necessary questions, and lets
you cancel at any time. The operations provided by this menu are also available from the browsing
modes, and are often easier to perform there.

</PARA>




</SECT1>



<SECT1>



<TITLE>

DELETE OPERATION

</TITLE>



<PARA>

If you choose the delete operation at the main menu, <APPLICATION>LifeLines</APPLICATION> displays the delete menu:
<SCREEN>
What do you want to delete?
  c Child - remove a child from his/her family
  s Spouse - remove a spouse from a family
  p Person - remove a person completely
  q Quit - return to the previous menu
</SCREEN>


</PARA>



<PARA>

These operations also work in a straightforward way. <APPLICATION>LifeLines</APPLICATION> asks you the necessary questions and
lets you cancel at any time.


</PARA>



<PARA>

You may also remove a child from his/her family, or remove a spouse/parent from his/her family,
from the person browsing mode. In both cases, only a relationship is removed, not a person. On the other
hand, the delete menu must be used if you want to completely remove a person from the database; this
cannot be done from the browsing mode.


</PARA>



<PARA>

There is no special operation for removing a family record. <APPLICATION>LifeLines</APPLICATION> silently removes any family
record that has no parent or child associated with it.

</PARA>



</SECT1>



<SECT1>



<TITLE>

CHARACTER TRANSLATION

</TITLE>



<PARA>

If you choose the modify character translation tables operation from the main menu, <APPLICATION>LifeLines</APPLICATION> displays
the character translation menu:
<SCREEN>
Which character mapping do you want to edit?
   e Editor to Internal mapping
   m Internal to Editor mapping
   i GEDCOM to Internal mapping
   x Internal to GEDCOM mapping
   d Internal to Display mapping
   r Internal to Report mapping
   q Return to main menu
</SCREEN>


</PARA>



<PARA>

<APPLICATION>LifeLines</APPLICATION> has little built-in knowledge of character codes. If you use 7-bit <ACRONYM>ASCII</ACRONYM> characters you will not
encounter problems. However, many European and other languages require additional characters, and
there are many 8-bit and other schemes for encoding those characters. <APPLICATION>LifeLines</APPLICATION> knows about none of
them. However, <APPLICATION>LifeLines</APPLICATION> provides a number of character translation features you can use to manage
character translation.

</PARA>



<PARA>

<APPLICATION>LifeLines</APPLICATION> provides facilities for mapping between characters whenever a data record changes form.
<APPLICATION>LifeLines</APPLICATION> supports four forms:<GLOSSLIST><GLOSSENTRY><GLOSSTERM>internal</GLOSSTERM><GLOSSDEF>

<PARA>

for records in the database

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM>editor</GLOSSTERM><GLOSSDEF>

<PARA>

for records being edited

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM>display</GLOSSTERM><GLOSSDEF>

<PARA>

for records being displayed

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM>report</GLOSSTERM><GLOSSDEF>

<PARA>

for records written to output file

</PARA>

</GLOSSDEF></GLOSSENTRY></GLOSSLIST>

</PARA>



<PARA>

When converting text from one form to another <APPLICATION>LifeLines</APPLICATION> normally does not convert characters codes.
You may, however, override this default behavior by creating translation tables that <APPLICATION>LifeLines</APPLICATION> will
use when converting between forms. There are six translation tables you may define. The following
table shows the six tables and describes when they are applied:<GLOSSLIST><GLOSSENTRY><GLOSSTERM>internal to editor</GLOSSTERM><GLOSSDEF>

<PARA>

when converting from internal, database form to editor form

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM>editor to internal</GLOSSTERM><GLOSSDEF>

<PARA>

when converting from editor form back to internal, database form

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><ACRONYM>GEDCOM</ACRONYM> to internal</GLOSSTERM><GLOSSDEF>

<PARA>

when reading <ACRONYM>GEDCOM</ACRONYM> input records and writing them to database

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM>internal to <ACRONYM>GEDCOM</ACRONYM></GLOSSTERM><GLOSSDEF>

<PARA>

when writing internal database records to external <ACRONYM>GEDCOM</ACRONYM> file

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM>internal to display</GLOSSTERM><GLOSSDEF>

<PARA>

when displaying a record in a browsing mode display screen

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM>internal to report</GLOSSTERM><GLOSSDEF>

<PARA>

when writing internal database records to external report file

</PARA>

</GLOSSDEF></GLOSSENTRY></GLOSSLIST>

</PARA>



<PARA>

After you select a translation table you are placed in the editor to edit the table. Translation tables are
made up of lines that look like:
<SYNOPSIS><REPLACEABLE>pattern</REPLACEABLE> <REPLACEABLE>pattern</REPLACEABLE></SYNOPSIS>
where a tab separates the patterns. Each pattern is an arbitrary sequence of verbatim <ACRONYM>ASCII</ACRONYM> characters
and escape sequences. Translation occurs by finding all occurrences that match left patterns and
replacing them with the corresponding right patterns.

</PARA>



<PARA>

There are five escape mechanisms used in patterns:<GLOSSLIST><GLOSSENTRY><GLOSSTERM>#nnn</GLOSSTERM><GLOSSDEF>

<PARA>

nnn is a decimal character value

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM>$hh</GLOSSTERM><GLOSSDEF>

<PARA>

hh is a hexadecimal character value

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM>\#</GLOSSTERM><GLOSSDEF>

<PARA>

represents the # character

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM>\$</GLOSSTERM><GLOSSDEF>

<PARA>

represents the $ character

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM>\\</GLOSSTERM><GLOSSDEF>

<PARA>

represents the \ character

</PARA>

</GLOSSDEF></GLOSSENTRY></GLOSSLIST>

</PARA>



<PARA>

The character translation feature is not fully tested, and not all translations are currently
implemented.

</PARA>



</SECT1>



<SECT1>



<TITLE>

MISCELLANEOUS UTILITIES

</TITLE>



<PARA>

If you choose the miscellaneous utilities operation, <APPLICATION>LifeLines</APPLICATION> displays the utilities menu:
<SCREEN>
What utility do you want to perform?
  s Save the database in a GEDCOM file
  r Read in data from a GEDCOM file
  k Find a person's key value
  i Identify a person from key value
  d Show database statistics
  m Show memory statistics
  e Edit the place abbreviation file
  o Edit the user options file
  q Return to the main menu
</SCREEN>


</PARA>



<PARA>

<GLOSSLIST><GLOSSENTRY><GLOSSTERM><KEYCAP>s</KEYCAP> <ACTION>Save the database in a GEDCOM file.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

This command saves the complete <APPLICATION>LifeLines</APPLICATION> database in a
<ACRONYM>GEDCOM</ACRONYM> file. All person, family, event, source and user-defined records are stored. This command
may be used to periodically back up your database. When you use this command, <APPLICATION>LifeLines</APPLICATION> asks you
for the name of the file. If you have defined the <ENVAR>LLARCHIVE</ENVAR> shell variable, <APPLICATION>LifeLines</APPLICATION> will store
the file in the directory named in the variable.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>r</KEYCAP> <ACTION>Read in data from a GEDCOM file.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

This command allows you restore a complete database from a
<ACRONYM>GEDCOM</ACRONYM> file. When you select this command, <APPLICATION>LifeLines</APPLICATION> asks you for the name of the <ACRONYM>GEDCOM</ACRONYM> file.
This command can also be used to import data from a <ACRONYM>GEDCOM</ACRONYM> file to an existing database. When
<APPLICATION>LifeLines</APPLICATION> performs this command, it first reads the entire <ACRONYM>GEDCOM</ACRONYM> file and checks it for validity.
If there are problems in the file, <APPLICATION>LifeLines</APPLICATION> describes them, writing them to the file err.log, and does
not add any records to the database. If there are no problems, <APPLICATION>LifeLines</APPLICATION> adds all the records found in
the file to the database (only header and trailer records are not stored in the database).

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>k</KEYCAP> <ACTION>Find a person's key value.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

This command finds the internal key value of a person.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>i</KEYCAP> <ACTION>Identify a person from key value.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

This command identifies the person that has a particular internal
key value.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>d</KEYCAP> <ACTION>Show database statistics.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

This command summarizes the contents of the current database. It
displays the number of person, family, source, event and other records in the database.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>m</KEYCAP> <ACTION>Show memory statistics.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

This command is used by the author for debugging.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>e</KEYCAP> <ACTION>Edit the place abbreviation file.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	This command allows you to edit the place abbreviations
	file. This file defines the abbreviations that are used by
	<APPLICATION>LifeLines</APPLICATION> when it creates lists of
	persons for you to select from. Each line in the file has the
	format:<SYNOPSIS><REPLACEABLE>word</REPLACEABLE>:<REPLACEABLE>
	abbr </REPLACEABLE></SYNOPSIS>where word is a word to be
	abbreviated, and abbr is its abbreviation. The word and its
	abbreviation are separated by a colon. For example:

<EXAMPLE>

<TITLE>
Example of using abbreviations
</TITLE>

<LITERALLAYOUT>Connecticut:Conn.
Massachusetts:Mass.
Nova Scotia:N.S.</LITERALLAYOUT></EXAMPLE>

</PARA>



<PARA>

When <APPLICATION>LifeLines</APPLICATION> constructs lists of persons for you to select from, it looks up the last component of
certain <STRUCTFIELD>PLAC</STRUCTFIELD> lines in this file, and if it finds that component, replaces it with its abbreviation.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>o</KEYCAP> <ACTION>Edit the user options file.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

This command allows you to edit the user options file. The user options file
is a record kept in the database that holds user selectable options. Each option has a name and a
string value. Each line in the options file has the format:<SYNOPSIS><REPLACEABLE>option</REPLACEABLE>=<REPLACEABLE>value</REPLACEABLE></SYNOPSIS>where option is the name of an option and value is the option's string value. If the value is more
than one line long, then the last character in each non-final line must be a backslash. In version &llversion
there are four options:<GLOSSLIST><GLOSSENTRY><GLOSSTERM>INDIREC</GLOSSTERM><GLOSSDEF>

<PARA>

Person record edit template

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM>EVENREC</GLOSSTERM><GLOSSDEF>

<PARA>

Event record edit template

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM>SOURREC</GLOSSTERM><GLOSSDEF>

<PARA>

Source record edit template

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM>OTHRREC</GLOSSTERM><GLOSSDEF>

<PARA>

Other record edit template

</PARA>

</GLOSSDEF></GLOSSENTRY></GLOSSLIST>

</PARA>



<PARA>

	For example if you would like to replace the default person
	record template with the following:

<EXAMPLE>

<TITLE>
Example of replacing the default person record template	
</TITLE>

<PROGRAMLISTING>

  0 INDI
  1 NAME //
  1 SEX</PROGRAMLISTING></EXAMPLE>you would edit the user option file to contain:<EXAMPLE>

<TITLE>
Example of replaced default person record template
</TITLE>

<LITERALLAYOUT>INDIREC=0 INDI\
  1 NAME //\
  1 SEX</LITERALLAYOUT>
</EXAMPLE>

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>q</KEYCAP> <ACTION>Return to main menu.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

This command returns you to the main menu.

</PARA>

</GLOSSDEF></GLOSSENTRY></GLOSSLIST>

</PARA>



</SECT1>



<SECT1>



<TITLE>

HANDLING SOURCE, EVENT AND USER-DEFINED RECORDS

</TITLE>



<PARA>

<APPLICATION>LifeLines</APPLICATION> supports source, event and other, user-defined record types. You access these features through
the x operation from the main menu. When you select this operation <APPLICATION>LifeLines</APPLICATION> displays the following
menu:
<SCREEN>
What activity do you want to perform?
  1 Add a source record to the database
  2 Edit source record from the database
  3 Add an event record to the database
  4 Edit event record from the database
  5 Add an other record to the database
  6 Edit other record from the database
  q Return to the main menu
</SCREEN>


</PARA>



<PARA>

The implementation of source, event and user-defined records is relatively new in <APPLICATION>LifeLines</APPLICATION>, and is still
primitive. For example, sources cannot be searched by title or by author, you cannot browse to sources or
events, as you can to persons and families, and so forth. In addition, there is no way to delete these new
records. These shortcomings may be addressed in future releases.

</PARA>

<GLOSSLIST><GLOSSENTRY><GLOSSTERM><KEYCAP>1</KEYCAP> <ACTION>Add a source record to the database.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

This operation is used to add a new source record to the
database. <APPLICATION>LifeLines</APPLICATION> creates a template source and puts you in the screen editor to edit the template.
The default template is:

<PROGRAMLISTING>

  0 SOUR
  1 REFN
  1 TITL <REPLACEABLE>Title</REPLACEABLE>
  1 AUTH <REPLACEABLE>Author</REPLACEABLE>

</PROGRAMLISTING>

</PARA>



<PARA>

	Do not change the <STRUCTFIELD>0 SOUR</STRUCTFIELD>
	line. Otherwise you may edit this record any way you like. The
	<STRUCTFIELD>1 REFN</STRUCTFIELD> line is a special line you
	can use to give the source a symbolic name that can be used in
	other records to refer to the source record. See the section
	on using <STRUCTFIELD>REFN</STRUCTFIELD> values. Because many
	sources have a title and an author, the default template has
	these lines. Here is how I recorded one of the sources in my
	database:

<EXAMPLE>

<TITLE>
Example of a source record
</TITLE>

<PROGRAMLISTING>

  0 SOUR
  1 REFN <USERINPUT>jcw</USERINPUT>
  1 TITL <USERINPUT>The Wetmore Family of America, and its Collateral Branches: with</USERINPUT>
    2 CONT <USERINPUT>Genealogical, Biographical, and Historical Notices</USERINPUT>
  1 AUTH <USERINPUT>James Carnahan Wetmore</USERINPUT>
  1 PUBL
    2 DATE <USERINPUT>1861</USERINPUT>
    2 PLAC <USERINPUT>Albany, New York</USERINPUT>
    2 INST <USERINPUT>Munsell and Rowland</USERINPUT>
    2 ADDR <USERINPUT>78 State Street</USERINPUT></PROGRAMLISTING></EXAMPLE>

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>2</KEYCAP> <ACTION>Edit source record from the database.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

Use this operation to edit an existing source record already in
the database. When you select this operation <APPLICATION>LifeLines</APPLICATION> asks you to identify a source:
<SCREEN>
Which source record do you want to edit?
enter key or refn:
</SCREEN>


</PARA>



<PARA>

Identify a source by entering its key value, with or without the leading S, or by entering its <STRUCTFIELD>REFN</STRUCTFIELD>
value. <APPLICATION>LifeLines</APPLICATION> retrieves the record and puts you in the editor with the record.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>3</KEYCAP> <ACTION>Add an event record to the database.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

This operation adds a new event record to the database.
<APPLICATION>LifeLines</APPLICATION> creates a template event and puts you in the screen editor to edit the template. The default
template is:<PROGRAMLISTING>

0 EVEN
  1 REFN
  1 DATE
  1 PLAC
  1 INDI
    2 NAME
    2 ROLE
  1 SOUR</PROGRAMLISTING>

</PARA>



<PARA>

	Do not change the 0 EVEN line. Otherwise you may edit this
	record any way you like. The <STRUCTFIELD>1 REFN</STRUCTFIELD>
	line allows you to give this event a symbolic name you can use
	when you want to refer to this event from other records. See
	the section on using <STRUCTFIELD>REFN</STRUCTFIELD>
	values. The default template suggests that an event has a
	date, a place, and refers to persons in roles with respect to
	the event. There is far less experience with event-based
	<ACRONYM>GEDCOM</ACRONYM> than there is with simple person and
	family <ACRONYM>GEDCOM</ACRONYM>. You may even be wondering
	why you would need event records when you can simply tuck
	events away in person and family records. This is a topic may
	get covered in an appendix.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>4</KEYCAP> <ACTION>Edit event record from the database.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Use this operation to edit an existing event record from the
	database. When you select this operation
	<APPLICATION>LifeLines</APPLICATION> asks you to identify an
	event:
	
<SCREEN>
Which event record do you want to edit?
enter key or refn:
</SCREEN>


</PARA>



<PARA>

	You identify a event by entering its key value, with or
	without the leading E, or by entering its
	<STRUCTFIELD>REFN</STRUCTFIELD>
	value. <APPLICATION>LifeLines</APPLICATION> retrieves the
	record and places you in the screen editor with the record.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>5</KEYCAP> <ACTION>Add an other record to the database.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	This operation adds a new user-defined record to the database.
	<APPLICATION>LifeLines</APPLICATION> creates a template and
	puts you in the screen editor to edit the template. The
	default template is:

<PROGRAMLISTING>
0 XXXX
1 REFN
</PROGRAMLISTING>
</PARA>



<PARA>

	Replace <REPLACEABLE>XXXX</REPLACEABLE> with the tag string
	you select for the type of the new record. You are free to
	choose any tag value except <STRUCTFIELD>INDI</STRUCTFIELD>,
	<STRUCTFIELD>FAM</STRUCTFIELD>,
	<STRUCTFIELD>SOUR</STRUCTFIELD> and
	<STRUCTFIELD>EVEN</STRUCTFIELD>. For example, if you keep
	record information about the ships that your North American
	immigrant ancestors arrived on, you would keep records about
	those ships in your database; the tag
	<STRUCTFIELD>SHIP</STRUCTFIELD> suggests itself for such
	records. The <STRUCTFIELD>1 REFN</STRUCTFIELD> line allows you
	to give this record a symbolic name you can use when you want
	to refer to it from other records. See the section on using
	<STRUCTFIELD>REFN</STRUCTFIELD> values.

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><KEYCAP>6</KEYCAP> <ACTION>Edit other record from the database.</ACTION></GLOSSTERM><GLOSSDEF>

<PARA>

	Use this operation to edit an existing user-defined record
	from the database. When you select this operation
	<APPLICATION>LifeLines</APPLICATION> asks you to identify the
	record:
	
<SCREEN>
What record do you want to edit?
enter key or refn:
</SCREEN>


</PARA>
	
<PARA>

	You identify a record by entering its key value, with or
	without the leading X, or by entering its
	<STRUCTFIELD>REFN</STRUCTFIELD>
	value. <APPLICATION>LifeLines</APPLICATION> retrieves the
	record and places you in the screen editor with the record.

</PARA>

</GLOSSDEF></GLOSSENTRY></GLOSSLIST>

</SECT1>



<SECT1>

<TITLE>
FAMILY STRUCTURE AND MERGING PERSONS AND FAMILIES
</TITLE>

<PARA>

	<APPLICATION>LifeLines</APPLICATION> 3.0.2 has relaxed most of
	restrictions on family structure that were imposed by earlier
	versions. For example, a family record may have more than one
	parent/spouse of the same sex; a person may be a child in more
	than family. This is a controversial issue. Some users insist
	that family relationships should imply biological relatedness,
	and that all other relationships should be handled by
	different means. Others insist that non-traditional families
	(any number of parents/spouses of any sex) should be allowed,
	and that children can be members of more than one family (eg,
	natural family and adoptive
	family). <APPLICATION>LifeLines</APPLICATION> no longer takes
	a position on this matter; you are free to set up families any
	way you like; the operations that add spouses and children to
	families no longer check for non-traditional arrangements. It
	is possible that a future release will include a user option
	to either disallow or to ask for confirmation about
	non-traditional relationships.

</PARA>



<PARA>

	<APPLICATION>LifeLines</APPLICATION> provides features for
	merging persons together and for merging families
	together. The person merging feature is accessed from the
	tandem person browse mode, and the family merging feature is
	accessed from the tandem family browse mode. You browse to the
	two persons or families you want to merge and then use the j
	command. Merging is necessary when you discover that two or
	more person records, or two or more family records, represent
	the same person or family, respectively.

</PARA>



<PARA>

	Versions of <APPLICATION>LifeLines</APPLICATION> prior to
	3.0.2 required that persons and families meet certain criteria
	before they could be merged. The criteria ensured that the
	merged persons and families would still meet traditional
	family structuring rules. With the relaxation of the
	structuring rules, restrictions on merging have also been
	removed. It is now possible to create non-traditional
	relationships by merging traditional persons and/or
	families. For example, if you merge two persons that happen to
	be children in two different families, the merged person will
	be a child in both families. If you want to maintain only
	traditional relationships in your database you may have to
	makes further to changes to relationships after you complete a
	merge operation.

</PARA>



</SECT1>



<SECT1>



<TITLE>

LINKING RECORDS TOGETHER AND USING THE REFN FEATURE

</TITLE>



<PARA>

	Records in a <APPLICATION>LifeLines</APPLICATION> database may
	refer to other records via cross-reference links. The
	lineage-linked references are maintained directly by
	<APPLICATION>LifeLines</APPLICATION> through operations found
	in the browsing mode menus.  These references are the links
	from a person to families (<STRUCTFIELD>1 FAMC</STRUCTFIELD>
	and <STRUCTFIELD>1 FAMS</STRUCTFIELD>), and the links from a
	family to persons (<STRUCTFIELD>1 HUSB</STRUCTFIELD>,
	<STRUCTFIELD>1 WIFE</STRUCTFIELD> and <STRUCTFIELD>1
	CHIL</STRUCTFIELD>). Because
	<APPLICATION>LifeLines</APPLICATION> maintains these links you
	are not allowed to change these lines when you are editing
	records. There are a couple of seeming exceptions to this
	rule. For example, you may change the order of <STRUCTFIELD>1
	CHIL</STRUCTFIELD> lines in a family record in order to change
	the order of children in a family, and you may change the
	order of <STRUCTFIELD>1 FAMS</STRUCTFIELD> lines in a person
	record to change the order of families the person was a spouse
	or parent in. These operations are allowed because they don't
	affect which person records refer to which family records and
	vice versa.

</PARA>



<PARA>

	Besides the lineage-links that are maintained by
	<APPLICATION>LifeLines</APPLICATION>, you may place your own
	links in records.  Probably the most common example of this is
	referring events within a person record to the record of the
	information source for the event. For example:

	
<EXAMPLE>

<TITLE>
Example of referring events from a person record
</TITLE>

<PROGRAMLISTING>

0 @I23@ INDI
  1 NAME <USERINPUT>Thomas/Whitmore/</USERINPUT>
  1 BIRT
    2 DATE <USERINPUT>about 1615</USERINPUT>
    2 PLAC <USERINPUT>England</USERINPUT>
    2 SOUR @S3@
...
0 @S3@ SOUR
  1 REFN <USERINPUT>cat</USERINPUT>
  1 TITL <USERINPUT>New England Marriages Prior to 1700</USERINPUT>
  1 AUTH <USERINPUT>Clarence Almon Torrey</USERINPUT>
...</PROGRAMLISTING></EXAMPLE>

</PARA>



<PARA>

The <STRUCTFIELD>2 SOUR</STRUCTFIELD> <REPLACEABLE>@S3@</REPLACEABLE> line in the person record refers to the source record. <APPLICATION>LifeLines</APPLICATION> allows any specific
structure within a record (in this case a birth event) to refer to another record. It is not possible to refer
to a specific location within another record, though this may be supported eventually.


</PARA>



<PARA>

This example implies that when linking one record to another you must know the key of the target
record (S3 in the example). This is not desirable because internal record keys may change when the
records are exported from one database or imported to another.

</PARA>



<PARA>

	Because internal key values are not permanent,
	<APPLICATION>LifeLines</APPLICATION> allows you to assign a
	permanent user-defined key to any record in the database using
	the <STRUCTFIELD>1 REFN</STRUCTFIELD> line. The value of this
	line is a string that you choose as your permanent key value
	for the record. When adding a link to a record that has a user
	<STRUCTFIELD>REFN</STRUCTFIELD> key value, you may use that
	value instead of the internal key value. For example, when
	adding the person in the previous example you could edit the
	new record as follows:

<EXAMPLE>

<TITLE>
Example of adding a new person
</TITLE>

<PROGRAMLISTING>

  0 INDI
  1 NAME <USERINPUT>Thomas/Whitmore/</USERINPUT>
  1 BIRT
    2 DATE <USERINPUT>about 1615</USERINPUT>
    2 PLAC <USERINPUT>England</USERINPUT>
    2 SOUR <USERINPUT>&lt;cat&gt;</USERINPUT></PROGRAMLISTING></EXAMPLE>

</PARA>



<PARA>

	Instead of using the actual key value of the source, S3, the
	<STRUCTFIELD>REFN</STRUCTFIELD> value cat was used. The
	<STRUCTFIELD>REFN</STRUCTFIELD> value must be enclosed by
	angle brackets when used this
	way. <APPLICATION>LifeLines</APPLICATION> automatically
	replaces the <STRUCTFIELD>REFN</STRUCTFIELD> link with the
	proper internal key value when the record is stored in the
	database.


</PARA>



<PARA>

	The <STRUCTFIELD>REFN</STRUCTFIELD> value may also be used
	when searching for person, source, event and user-defined
	records.  You should not add more than one
	<STRUCTFIELD>REFN</STRUCTFIELD> line to a record, and every
	<STRUCTFIELD>REFN</STRUCTFIELD> value should be unique.

</PARA>



</SECT1>



<SECT1>



<TITLE>

THE <APPLICATION>LIFELINES</APPLICATION> PROGRAMMING SUBSYSTEM AND REPORT GENERATOR

</TITLE>



<PARA>

	The <APPLICATION>LifeLines</APPLICATION> programming subsystem
	lets you produce reports in any style or layout. You may
	generate files in <APPLICATION>troff</APPLICATION>,
	<APPLICATION>Postscript</APPLICATION>,
	<APPLICATION>TeX</APPLICATION>, <ACRONYM>SGML</ACRONYM> or any
	other <ACRONYM>ASCII</ACRONYM>-based format, for further text
	processing and printing. You access the report generator by
	choosing the r command from the main menu. You may also use
	the programming subsystem to create query and other processing
	programs that write their results directly upon the
	screen. For example, there is a
	<APPLICATION>LifeLines</APPLICATION> program that computes the
	relationship between any two persons in a database.

</PARA>



<PARA>

	Each <APPLICATION>LifeLines</APPLICATION> program is written
	in the <APPLICATION>LifeLines</APPLICATION> programming
	language, and the programs are stored in normal files. When
	you direct <APPLICATION>LifeLines</APPLICATION> to run a
	program, it asks you for the name of the program file, asks
	you where you want the program's output written, and then runs
	the program.

</PARA>



<PARA>

	For example, say you want <APPLICATION>LifeLines</APPLICATION>
	to generate an ahnentafel. Such a report might look
	like:

<EXAMPLE>

<TITLE>
Example of ahnentafel report	
</TITLE>

<LITERALLAYOUT>
1. Thomas Trask WETMORE IV
b. 18 December 1949, New London, Connecticut
2. Thomas Trask WETMORE III
b. 15 October 1925, New London, Connecticut
3. Joan Marie HANCOCK
b. 6 June 1928, New London, Connecticut
4. Thomas Trask WETMORE Jr
b. 5 May 1896, New London, Connecticut
d. 8 November 1970, New London, Connecticut
5. Vivian Genevieve BROWN
b. 5 April 1896, Mondovi, Wisconsin
6. Richard James HANCOCK
b. 18 August 1904, New London, Connecticut
d. 24 December 1976, Waterford, Connecticut
7. Muriel Armstrong SMITH
b. 28 October 1905, New Haven, Connecticut
8. Thomas Trask WETMORE Sr
b. 13 March 1866, St. Mary's Bay, Nova Scotia
d. 17 February 1947, New London, Connecticut
9. Margaret Ellen KANEEN
b. 27 October 1859, Liverpool, England
d. 10 May 1900, New London, Connecticut
... lots more</LITERALLAYOUT></EXAMPLE>

</PARA>



<PARA>

	Here is a <APPLICATION>LifeLines</APPLICATION> program that
	generates this report:

<EXAMPLE>

<TITLE>
Example of ahnentafel report script	
</TITLE>

<PROGRAMLISTING>

proc main ()
  {
    getindi(indi)
    list(ilist)
    list(alist)
    enqueue(ilist, indi)
    enqueue(alist, 1)
    while(indi, dequeue(ilist)) {
      set(ahnen, dequeue(alist))
      d(ahnen) ". " name(indi) nl()
      if (e, birth(indi)) { " b. " long(e) nl() }
      if (e, death(indi)) { " d. " long(e) nl() }
      if (par, father(indi)) {
        enqueue(ilist, par)
        enqueue(alist, mul(2,ahnen))
      }
      if (par,mother(indi)) {
        enqueue(ilist, par)
        enqueue(alist, add(1,mul(2,ahnen)))
      }
    }
  }</PROGRAMLISTING></EXAMPLE>

</PARA>



<PARA>

	Say this program is in the file
	<FILENAME>ahnen</FILENAME>. When you choose the
	<KEYCAP>r</KEYCAP> option from the main menu,
	<APPLICATION>LifeLines</APPLICATION> asks:
	
<SCREEN>
What is the name of the report program?
enter string:
</SCREEN>

</PARA>

<PARA>

	You enter
	<USERINPUT><LITERAL>ahnen</LITERAL></USERINPUT>. Since the
	program generates a report,
	<APPLICATION>LifeLines</APPLICATION> asks where to write that
	report:

<SCREEN>
What is the name of the output file?
enter file name:
</SCREEN>

</PARA>



<PARA>

	You enter a file name, say
	<USERINPUT><FILENAME>my.ahnen</FILENAME></USERINPUT>.
	<APPLICATION>LifeLines</APPLICATION> reads the program ahnen,
	executes the program, and writes the report output to
	<FILENAME>my.ahnen</FILENAME>. <APPLICATION>LifeLines</APPLICATION>
	reports any syntax or run-time errors found while trying to
	run the program.


</PARA>



<PARA>

	A <APPLICATION>LifeLines</APPLICATION> program is made up of
	<TYPE>procedures</TYPE> and <TYPE>functions</TYPE>; every
	program must contain at least one <TYPE>procedure</TYPE> named
	<LITERAL>main</LITERAL>. The <LITERAL>main</LITERAL>
	<TYPE>procedure</TYPE> runs first; it may call other
	<TYPE>procedures</TYPE>, <TYPE>functions</TYPE> and
	<TYPE>built-in functions</TYPE>. In the ahnentafel example
	there is only one <TYPE>procedure</TYPE>.

</PARA>



<PARA>

	A <TYPE>procedure</TYPE> body is a sequence of
	<TYPE>statements</TYPE>. In the example program the first five
	<TYPE>statements</TYPE> are:

<PROGRAMLISTING>
getindi(indi)
list(ilist)
list(alist)
enqueue(ilist, indi)
enqueue(alist, 1)
</PROGRAMLISTING>
</PARA>



<PARA>

	The first <TYPE>statement</TYPE> calls the
	<FUNCTION>getindi</FUNCTION> (get individual) <TYPE>built-in
	function</TYPE>, which causes
	<APPLICATION>LifeLines</APPLICATION> to ask you to identify a
	person using the zip browse style of identification:
	
<SCREEN>
Identify person for interpreted report
enter name:
</SCREEN>


</PARA>



<PARA>

	After you identify a person, he or she is assigned to the
	variable <VARNAME>indi</VARNAME>. The next two
	<TYPE>statements</TYPE> declare two <TYPE>list
	variables</TYPE>, <VARNAME>ilist</VARNAME> and
	<VARNAME>alist</VARNAME>. <TYPE>Lists</TYPE> hold sequences of
	things; there are operations for placing things on lists,
	taking things off, and iterating through the list elements. In
	the example, <VARNAME>ilist</VARNAME> holds a list of
	ancestors, in ahnentafel order, who have not yet been reported
	on, and <VARNAME>alist</VARNAME> holds their respective
	ahnentafel numbers.


</PARA>



<PARA>

	The next two statements call the <FUNCTION>enqueue</FUNCTION>
	function, adding the first members to both lists. The person
	identified by the <FUNCTION>getindi</FUNCTION> function is
	made the first member of <VARNAME>ilist</VARNAME>, and the
	number one, this person's ahnentafel number, is made the first
	member of <VARNAME>alist</VARNAME>.

</PARA>



<PARA>

The rest of the program is:
	
<PROGRAMLISTING>
while(indi, dequeue(ilist)) {
  set(ahnen, dequeue(alist))
  d(ahnen) ". " name(indi) nl()
  if (e, birth(indi)) { " b. " long(e) nl() }
  if (e, death(indi)) { " d. " long(e) nl() }
  if (par, father(indi)) {
    enqueue(ilist, par)
    enqueue(alist, mul(2,ahnen))
  }
  if (par, mother(indi)) {
    enqueue(ilist, par)
   enqueue(alist, add(1,mul(2,ahnen)))
  }
}
</PROGRAMLISTING>

</PARA>



<PARA>

	This is a loop that iteratively removes persons and their
	ahnentafel numbers from the two lists, and then prints their
	names and birth and death information. If the persons have
	parents in the database, their parents and their parents'
	ahnentafel numbers are then put at the ends of the lists. The
	loop iterates until the list is empty.

</PARA>



<PARA>

	The loop is a <TYPE>while</TYPE> loop statement. The line:
<PROGRAMLISTING>
while(indi, dequeue(ilist)) {
</PROGRAMLISTING>
removes (via <FUNCTION>dequeue</FUNCTION>) a person from <VARNAME>ilist</VARNAME>, and assigns the person to variable <VARNAME>indi</VARNAME>. As long as there
are persons on <VARNAME>ilist</VARNAME>, another iteration of the loop follows.

</PARA>



<PARA>

The statement:<PROGRAMLISTING>

set(ahnen, dequeue(alist))</PROGRAMLISTING>is an <TYPE>assignment</TYPE> statement. The second argument is evaluated; its value is assigned to the first
argument, which must be a variable. Here the next number in <VARNAME>alist</VARNAME> is removed and assigned to variable
<VARNAME>ahnen</VARNAME>. This is the ahnentafel number of the person just removed from <VARNAME>ilist</VARNAME>.

</PARA>



<PARA>

The line:<PROGRAMLISTING>

d(ahnen) ". " name(indi) nl()</PROGRAMLISTING>contains four <TYPE>expression</TYPE> statements; when expressions are used as statements, their values, if any, are
treated as strings and written directly to the report output file. The <FUNCTION>d</FUNCTION> function converts its integer
argument to a numeric string. The ". " is a literal (constant) string value. The <FUNCTION>name</FUNCTION> function returns the
default form of a person's name. The <FUNCTION>nl</FUNCTION> function returns a string containing the newline character.

</PARA>



<PARA>

The next two lines:<PROGRAMLISTING>

if(e, birth(indi)) { " b. " long(e) nl() }
if(e, death(indi)) { " d. " long(e) nl() }</PROGRAMLISTING>write out basic birth and death information about a person. These lines are <TYPE>if</TYPE> statements. The second
argument in the conditional is evaluated and assigned to the first argument, which must be a variable.
The first <TYPE>if</TYPE> statement calls the birth function, returning the first birth event in a person's record. If the
event exists it is assigned to variable <VARNAME>e</VARNAME>, and the <TYPE>body</TYPE> (the items between the curly brackets) of the <TYPE>if</TYPE>
statement is executed. The <TYPE>body</TYPE> consists of three <TYPE>expression</TYPE> statements: a literal, and calls to the <FUNCTION>long</FUNCTION>
and <FUNCTION>nl</FUNCTION> functions. <FUNCTION>Long</FUNCTION> takes an <PARAMETER><TYPE>event</TYPE></PARAMETER> and returns the values of the first <STRUCTFIELD>DATE</STRUCTFIELD> and <STRUCTFIELD>PLAC</STRUCTFIELD> lines in the
<TYPE>event</TYPE>.

</PARA>



<PARA>

Finally in the program is:<PROGRAMLISTING>

if (par, father(indi)) {
enqueue(ilist,par)
enqueue(alist,mul(2,ahnen))
}
if (par,mother(indi)) {
enqueue(ilist,par)
enqueue(alist,add(1,mul(2,ahnen)))
}</PROGRAMLISTING>

</PARA>



<PARA>

These lines add the father and mother of the current person, if either or both are in the database, to
<VARNAME>ilist</VARNAME>. They also compute and add the parents' ahnentafel numbers to <VARNAME>alist</VARNAME>. A father's ahnentafel
number is twice that of his child. A mother's ahnentafel number is twice that of her child plus one.
These values are computed with the <FUNCTION>mul</FUNCTION> and <FUNCTION>add</FUNCTION> functions.

</PARA>



</SECT1>

</CHAPTER><CHAPTER>

<TITLE>

<APPLICATION>LIFELINES</APPLICATION> PROGRAMMING REFERENCE

</TITLE>



<PARA>

<APPLICATION>LifeLines</APPLICATION> programs are stored in files you edit with a screen editor. Programs are not edited from within
the <APPLICATION>LifeLines</APPLICATION> program; edit them as you would any text file. The programs may be stored in any
directories; they do not have to be kept in or associated with <APPLICATION>LifeLines</APPLICATION> databases. You may set the
<ENVAR>LLPROGRAMS</ENVAR> shell variable to hold a list of directories that <APPLICATION>LifeLines</APPLICATION> will use to automatically
search for programs when you request program execution.

</PARA>



<SECT1>



<TITLE>

Procedures and Functions

</TITLE>



<PARA>

A <APPLICATION>LifeLines</APPLICATION> program is made up of one or more <TYPE>procedures</TYPE> and <TYPE>functions</TYPE>. A <TYPE>procedure</TYPE> has format:<SYNOPSIS>proc name ( params ) { statements }</SYNOPSIS>

</PARA>



<PARA>

<SYMBOL>Name</SYMBOL> is the name of the <TYPE>procedure</TYPE>, <SYMBOL>params</SYMBOL> is an optional list of <TYPE>parameters</TYPE> separated by commas,
and <SYMBOL>statements</SYMBOL> is a list of statements that make up the <TYPE>procedure</TYPE> body. Report generation begins with
the first <TYPE>statement</TYPE> in the <TYPE>procedure</TYPE> named <LITERAL>main</LITERAL>. <TYPE>Procedures</TYPE> may call other <TYPE>procedures</TYPE> and <TYPE>functions</TYPE>.
<TYPE>Procedures</TYPE> are called with the <TYPE>call</TYPE> statement described below.When a <TYPE>procedure</TYPE> is called, the
<TYPE>statements</TYPE> making up its <TYPE>body</TYPE> are executed.

</PARA>



<PARA>

A function has format:<SYNOPSIS>func name ( params ) { statements }</SYNOPSIS>

</PARA>



<PARA>

<SYMBOL>Name</SYMBOL>, <SYMBOL>params</SYMBOL> and <SYMBOL>statements</SYMBOL> are defined as in <TYPE>procedures</TYPE>. <TYPE>Functions</TYPE> may call other <TYPE>procedures</TYPE> and
<TYPE>functions</TYPE>. When a <TYPE>function</TYPE> is called the <TYPE>statements</TYPE> that make it up are executed. A <TYPE>function</TYPE> differs from
a <TYPE>procedure</TYPE> by returning a <TYPE>value</TYPE> to the <TYPE>procedure</TYPE> or <TYPE>function</TYPE> that calls it. Values are returned by the
<TYPE>return</TYPE> statement, described below. <TYPE>Recursive functions</TYPE> are allowed. A <TYPE>function</TYPE> is called by invoking it
in an <TYPE>expression</TYPE>.

</PARA>



</SECT1>



<SECT1>



<TITLE>

Comments

</TITLE>



<PARA>

You may comment your <APPLICATION>LifeLines</APPLICATION> programs using the following notation:<PROGRAMLISTING>

/*...comment text including any characters except */... */</PROGRAMLISTING>

</PARA>



<PARA>

Comments begin with a <LITERAL>/*</LITERAL> and end with a <LITERAL>*/</LITERAL>. Comments may appear on lines of their own or on lines
that have program constructs. Comments may span many lines. Comments may not be nested.

</PARA>



</SECT1>



<SECT1>



<TITLE>

Statements

</TITLE>



<PARA>

	There are a number of <TYPE>statement</TYPE> types. The
	simplest is an <TYPE>expression</TYPE> statement, an
	expression that is not part of any other
	<TYPE>statement</TYPE> or
	<TYPE>expression</TYPE>. <TYPE>Expressions</TYPE> are defined
	more fully below. An <TYPE>expression</TYPE> statement is
	evaluated, and if its value is
	<RETURNVALUE>non-null</RETURNVALUE> (non-zero), it is assumed
	to be a <TYPE>string</TYPE>, and written to the program output
	file. If its value is <RETURNVALUE>null</RETURNVALUE>, nothing
	is written to the output file. For example, the expression
	<SYNOPSIS>name(indi)</SYNOPSIS>, where <SYMBOL>indi</SYMBOL>
	is a person, returns the person's name and writes it to the
	output file. On the other hand, the expression
	<SYNOPSIS>set(n, nspouses(indi))</SYNOPSIS> assigns the
	variable <VARNAME>n</VARNAME> the number of spouses that
	person <VARNAME>indi</VARNAME> has, but since
	<FUNCTION>set</FUNCTION> returns
	<RETURNVALUE>null</RETURNVALUE>, nothing is written to the
	output file.

</PARA>



<PARA>

	The programming language includes <TYPE>if</TYPE> statements,
	<TYPE>while</TYPE> statements and <TYPE>procedure call</TYPE>
	statements, with the following formats:

	<SYNOPSIS>if ([varb,] expr) { statements } 
	          [ elsif ([varb], expr) { statements } ]*
     	          [ else { statements } ]
	</SYNOPSIS>

	<SYNOPSIS>while ([varb,] expr ) { statements }</SYNOPSIS>

	<SYNOPSIS>call name ( args )</SYNOPSIS>

</PARA>



<PARA>

Square brackets indicate optional parts of the statement syntax. An <TYPE>if</TYPE> statement is executed by first
evaluating the conditional expression in the <TYPE>if</TYPE> clause. If <RETURNVALUE>non-zero</RETURNVALUE>, the statements in the <TYPE>if</TYPE> clause are
evaluated, and the rest of the <TYPE>if</TYPE> statement, if any, is ignored. If the value is <RETURNVALUE>zero</RETURNVALUE>, and there is an <TYPE>elsif</TYPE>
clause following, the conditional in the <TYPE>elsif</TYPE> clause is evaluated, and if <RETURNVALUE>non-zero</RETURNVALUE>, the statements in
that clause are executed. <TYPE>Conditionals</TYPE> are evaluated until one of them is <RETURNVALUE>non-zero</RETURNVALUE>, or until there are no
more. If no conditional is <RETURNVALUE>non-zero</RETURNVALUE>, and if the <TYPE>if</TYPE> statement ends with an <TYPE>else</TYPE> clause, the statements in
the <TYPE>else</TYPE> clause are executed. There are two forms of <TYPE>conditional</TYPE> expressions. If the <TYPE>conditional</TYPE> is a
single <TYPE>expression</TYPE>, it is simply evaluated. If the <TYPE>conditional</TYPE> is a <TYPE>variable</TYPE> followed by an <TYPE>expression</TYPE>, the
<TYPE>expression</TYPE> is evaluated and its value is assigned to the variable.

</PARA>

<PARA>

Note that <TYPE>if</TYPE> treats null strings as false, but empty strings as true. This has the benefit that

<PROGRAMLISTING>
if(birth(indi))
</PROGRAMLIST>

will return true if there is a BIRT record, even if it is empty, but will return false if there is no BIRT record
at all.

</PARA>

<PARA>

The <TYPE>while</TYPE> statement provides a looping mechanism. The <TYPE>conditional</TYPE> is evaluated, and if <RETURNVALUE>non-zero</RETURNVALUE>, the
<TYPE>body</TYPE> of the loop is executed. After each iteration the <TYPE>expression</TYPE> is reevaluated; as long as it remains
<RETURNVALUE>non-zero</RETURNVALUE>, the loop is repeated.


</PARA>



<PARA>

The <TYPE>call</TYPE> statement provides procedure calls. <SYMBOL>Name</SYMBOL> must match one of the <TYPE>procedures</TYPE> defined in the
report program. <SYMBOL>Args</SYMBOL> is a list of <TYPE>argument</TYPE> expressions separated by commas. <TYPE>Recursion</TYPE> is allowed.
When a <TYPE>call</TYPE> is executed, the values of its <TYPE>arguments</TYPE> are evaluated and used to initialize the
procedure's <TYPE>parameters</TYPE>. The <TYPE>procedure</TYPE> is then executed. When the <TYPE>procedure</TYPE> completes, execution
resumes with the first item after the call.

</PARA>



<PARA>

The report language also includes the following statement types:<SYNOPSIS>include(string)</SYNOPSIS><SYNOPSIS>global(varb)
</SYNOPSIS><SYNOPSIS>set(varb, expr)
</SYNOPSIS><SYNOPSIS>continue()
</SYNOPSIS><SYNOPSIS>break()
</SYNOPSIS><SYNOPSIS>return([expr])</SYNOPSIS>

</PARA>



<PARA>

The <TYPE>include</TYPE> statement includes the contents of another file into the current file; its <PARAMETER>string</PARAMETER> expression is
the name of another <APPLICATION>LifeLines</APPLICATION> program file. It is described in more detail below. The <TYPE>global</TYPE> statement
must be used outside the scope of any <TYPE>procedure</TYPE> or <TYPE>function</TYPE>; it declares a <PARAMETER>variable</PARAMETER> to have global scope.
The <TYPE>set</TYPE> statement is the assignment statement; the <PARAMETER>expression</PARAMETER> is evaluated, and its value is assigned
to the <PARAMETER>variable</PARAMETER>. The <TYPE>continue</TYPE> statement jumps to the bottom of the current loop, but does not leave the
loop. The <TYPE>break</TYPE> statement breaks out of the most closely nested loop. The <TYPE>return</TYPE> statement returns from
the current <TYPE>procedure</TYPE> or <TYPE>function</TYPE>. <TYPE>Procedures</TYPE> have return statements without expressions; <TYPE>functions</TYPE>
have return statements with expressions. None of these statements return a value, so none has a direct
effect on program output.


</PARA>



<PARA>

In addition to these conventional statements, the report generator provides other iterator statements
for looping through genealogical and other types of data. For example, the <TYPE>children</TYPE> statement
iterates through the children of a family, the <TYPE>spouses</TYPE> statement iterates through the spouses of a
person, and the <TYPE>families</TYPE> statement iterates through the families that a person is a spouse or parent in.
These iterators and others are described in more detail later under the appropriate data types.

</PARA>



</SECT1>



<SECT1>



<TITLE>

Expressions

</TITLE>



<PARA>

There are four types of expressions: <TYPE>literals</TYPE>, <TYPE>integers</TYPE>, <TYPE>variables</TYPE> and built-in or user defined function
<TYPE>calls</TYPE>.


</PARA>



<PARA>

A <TYPE>literal</TYPE> is any string enclosed in double quotes; its value is itself. An <TYPE>integer</TYPE> is any integer constant;
its value is itself. A <TYPE>variable</TYPE> is a named location that can be assigned different values during program
execution. The value of a <TYPE>variable</TYPE> is the last value assigned to it. <TYPE>Variables</TYPE> do not have fixed type; at
different times in a program, the same <TYPE>variable</TYPE> may be assigned data of completely different types. An
identifier followed by comma-separated list of expressions enclosed in parentheses, is either a <TYPE>call</TYPE> to a
built-in function or a <TYPE>call</TYPE> to a user-defined function.

</PARA>



</SECT1>



<SECT1>



<TITLE>

Include Feature

</TITLE>



<PARA>

The <APPLICATION>LifeLines</APPLICATION> programming language provides an <TYPE>include</TYPE> feature. Using this feature one <APPLICATION>LifeLines</APPLICATION>
program can refer to other <APPLICATION>LifeLines</APPLICATION> programs. This feature is provided by the include statement:<SYNOPSIS>include(string)</SYNOPSIS>where <SYMBOL>string</SYMBOL> is a quoted string that is the name of another <APPLICATION>LifeLines</APPLICATION> program file. When an include
statement is encountered, the program that it refers to is read at that point, exactly as if the contents of
included file had been in the body of the original file at that point. This allows you to create <APPLICATION>LifeLines</APPLICATION>
program library files that can be used by many programs. Included files may in turn contain <TYPE>include</TYPE>
statements, and so on to any depth. <APPLICATION>LifeLines</APPLICATION> will use the <ENVAR>LLPROGRAMS</ENVAR> shell variable, if set, to
search for the <TYPE>include</TYPE> files.

</PARA>



</SECT1>



<SECT1>



<TITLE>

Built-in Functions

</TITLE>



<PARA>

There is a long list of <TYPE>built-in functions</TYPE>, and this list will continue to grow for some time. The first
subsection below describes the value types used in <APPLICATION>LifeLines</APPLICATION> programs; these are the types of <TYPE>variables</TYPE>,
<TYPE>function parameters</TYPE> and <TYPE>function return values</TYPE>. In the remaining sections the <TYPE>built-in functions</TYPE> are
separated into logical categories and described.

</PARA>



</SECT1>



<SECT1>



<TITLE>

Value Types

</TITLE>

<GLOSSLIST><GLOSSENTRY><GLOSSTERM><TYPE>ANY</TYPE></GLOSSTERM><GLOSSDEF>

<PARA>

union of all types

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><TYPE>INT</TYPE></GLOSSTERM><GLOSSDEF>

<PARA>

integer (on most systems a 32-bit signed value)

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><TYPE>BOOL</TYPE></GLOSSTERM><GLOSSDEF>

<PARA>

boolean (0 represents false; anything else represents true)

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><TYPE>STRING</TYPE></GLOSSTERM><GLOSSDEF>

<PARA>

text string

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><TYPE>LIST</TYPE></GLOSSTERM><GLOSSDEF>

<PARA>

arbitrary length list of any values

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><TYPE>TABLE</TYPE></GLOSSTERM><GLOSSDEF>

<PARA>

keyed look-up table

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><TYPE>INDI</TYPE></GLOSSTERM><GLOSSDEF>

<PARA>

person; reference to a <ACRONYM>GEDCOM</ACRONYM> INDI record

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><TYPE>FAM</TYPE></GLOSSTERM><GLOSSDEF>

<PARA>

family; reference to a <ACRONYM>GEDCOM</ACRONYM> FAM record

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><TYPE>SET</TYPE></GLOSSTERM><GLOSSDEF>

<PARA>

arbitrary length set of persons

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><TYPE>NODE</TYPE></GLOSSTERM><GLOSSDEF>

<PARA>

<ACRONYM>GEDCOM</ACRONYM> node; reference to a line in a <ACRONYM>GEDCOM</ACRONYM> tree/record

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><TYPE>EVENT</TYPE></GLOSSTERM><GLOSSDEF>

<PARA>

event; reference to substructure of nodes in a <ACRONYM>GEDCOM</ACRONYM> record

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><TYPE>VOID</TYPE></GLOSSTERM><GLOSSDEF>

<PARA>

type with no values

</PARA>

</GLOSSDEF></GLOSSENTRY></GLOSSLIST>

<PARA>

In the summaries of <TYPE>built-in functions</TYPE> below, each function is shown with its <TYPE>argument</TYPE> types and its
<TYPE>return</TYPE> type. The types are from the preceding list. Sometimes an <TYPE>argument</TYPE> to a <TYPE>built-in function</TYPE> must be
a <TYPE>variable</TYPE>; when this is so its type is given as <VARNAME>XXX_V</VARNAME>, where <SYMBOL>XXX</SYMBOL> is one of the types above. The
<TYPE>built-ins</TYPE> do not check the types of their <TYPE>arguments</TYPE>. <TYPE>Variables</TYPE> can hold values of any type, though at
any one time they will hold values of only one type. Note that <TYPE>EVENT</TYPE> is a subtype of <TYPE>NODE</TYPE>, and
<TYPE>BOOL</TYPE> is a subtype of <TYPE>INT</TYPE>. Built-ins with type <TYPE>VOID</TYPE> actually return <RETURNVALUE>null</RETURNVALUE> (zero) values.

</PARA>



</SECT1>



<SECT1>



<TITLE>

Arithmetic and Logic Functions

</TITLE>


<GLOSSLIST><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>INT <FUNCTION>add</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INT</PARAMETER><PARAMETER>INT</PARAMETER><PARAMETER>...</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

addition - two to 32 arguments

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>INT <FUNCTION>sub</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INT</PARAMETER><PARAMETER>INT</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

subtraction

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>INT <FUNCTION>mul</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INT</PARAMETER><PARAMETER>INT</PARAMETER><PARAMETER>...</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

multiplication - two to 32 arguments

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>INT <FUNCTION>div</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INT</PARAMETER><PARAMETER>INT</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

division

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>INT <FUNCTION>mod</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INT</PARAMETER><PARAMETER>INT</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

modulus (remainder)

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>INT <FUNCTION>exp</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INT</PARAMETER><PARAMETER>INT</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

exponentiation

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>INT <FUNCTION>neg</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INT</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

integer negation

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>incr</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INT_V</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

increment variable by one

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>decr</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INT_V</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

decrement variable by one

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>BOOL <FUNCTION>and</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>BOOL</PARAMETER><PARAMETER>BOOL</PARAMETER><PARAMETER>...</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

logical and - two to 32 arguments

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>BOOL <FUNCTION>or</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>BOOL</PARAMETER><PARAMETER>BOOL</PARAMETER><PARAMETER>...</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

logical or - two to 32 arguments

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>BOOL <FUNCTION>not</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>BOOL</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

logical not

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>BOOL <FUNCTION>eq</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>ANY</PARAMETER><PARAMETER>ANY</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

equality (not strings)

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>BOOL <FUNCTION>ne</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>ANY</PARAMETER><PARAMETER>ANY</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

non-equality

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>BOOL <FUNCTION>lt</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>ANY</PARAMETER><PARAMETER>ANY</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

less than

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>BOOL <FUNCTION>gt</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>ANY</PARAMETER><PARAMETER>ANY</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

greater than

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>BOOL <FUNCTION>le</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>ANY</PARAMETER><PARAMETER>ANY</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

less than or equal

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>BOOL <FUNCTION>ge</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>ANY</PARAMETER><PARAMETER>ANY</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

greater than or equal

</PARA>

</GLOSSDEF></GLOSSENTRY></GLOSSLIST>

<PARA>

<FUNCTION>Add</FUNCTION>, <FUNCTION>sub</FUNCTION>, <FUNCTION>mul</FUNCTION> and <FUNCTION>div</FUNCTION> do integer arithmetic. Functions <FUNCTION>add</FUNCTION> and <FUNCTION>mul</FUNCTION> can have two to 32 arguments;
the sum or product of the full set of arguments is computed. Functions <FUNCTION>sub</FUNCTION> and <FUNCTION>div</FUNCTION> have two arguments
each; <FUNCTION>sub</FUNCTION> subtracts its second argument from its first, and <FUNCTION>div</FUNCTION> divides its first argument by its second.
The <FUNCTION>mod</FUNCTION> function returns the remainder after dividing the first parameter by the second. If the second
argument to <FUNCTION>div</FUNCTION> or <FUNCTION>mod</FUNCTION> is zero, these functions return 0 and generate a run time error. <FUNCTION>Exp</FUNCTION> performs
integer exponentiation. <FUNCTION>Neg</FUNCTION> negates its argument.

</PARA>



<PARA>

<FUNCTION>Incr</FUNCTION> and <FUNCTION>decr</FUNCTION> increment by one and decrement by one, respectively, the value of a variable. The
argument to both functions must be a variable.

</PARA>



<PARA>

<FUNCTION>And</FUNCTION> and <FUNCTION>or</FUNCTION> do logical operations. Both functions take two to 32 arguments. All arguments are and'ed or
or'ed together, respectively. The arguments are evaluated from left to right, but only up to the point
where the final value of the function becomes known. <FUNCTION>Not</FUNCTION> does the logical not operation.

</PARA>



<PARA>

<FUNCTION>Eq</FUNCTION>, <FUNCTION>ne</FUNCTION>, <FUNCTION>lt</FUNCTION>, <FUNCTION>le</FUNCTION>, <FUNCTION>gt</FUNCTION> and <FUNCTION>ge</FUNCTION> evaluate the six ordering relationships between two integers.

</PARA>



</SECT1>



<SECT1>



<TITLE>

Person Functions

</TITLE>

<GLOSSLIST><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>name</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INDI</PARAMETER><PARAMETER><OPTIONAL>BOOL</OPTIONAL></PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

default name of

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>fullname</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INDI</PARAMETER><PARAMETER>BOOL</PARAMETER><PARAMETER>BOOL</PARAMETER><PARAMETER>INT</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

many name forms of

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>surname</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INDI</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

surname of

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>givens</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INDI</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

given names of

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>trimname</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INDI</PARAMETER><PARAMETER>INT</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

trimmed name of

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>EVENT <FUNCTION>birth</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INDI</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

first birth event of

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>EVENT <FUNCTION>death</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INDI</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

first death event of

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>EVENT <FUNCTION>baptism</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INDI</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

first baptism event of

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>EVENT <FUNCTION>burial</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INDI</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

first burial event of

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>INDI <FUNCTION>father</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INDI</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

first father of

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>INDI <FUNCTION>mother</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INDI</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

first mother of

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>INDI <FUNCTION>nextsib</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INDI</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

next (younger) sibling of

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>INDI <FUNCTION>prevsib</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INDI</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

previous (older) sibling of

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>sex</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INDI</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

sex of

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>BOOL <FUNCTION>male</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INDI</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

male predicate

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>BOOL <FUNCTION>female</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INDI</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

female predicate

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>pn</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INDI</PARAMETER><PARAMETER>INT</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

pronoun referring to

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>INT <FUNCTION>nspouses</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INDI</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

number of spouses of

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>INT <FUNCTION>nfamilies</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INDI</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

number of families (as spouse/parent) of

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>FAM <FUNCTION>parents</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INDI</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

first parents' family of

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>title</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INDI</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

first title of

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>key</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INDI|FAM</PARAMETER><PARAMETER><OPTIONAL>BOOL</OPTIONAL></PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

internal key of (work for families also)

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>soundex</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INDI</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

SOUNDEX code of

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>NODE <FUNCTION>inode</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INDI</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

root GEDCOM node of

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>NODE <FUNCTION>root</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INDI</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

root GEDCOM node of

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>INDI <FUNCTION>indi</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>STRING</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

find person with key value

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>INDI <FUNCTION>firstindi</FUNCTION></FUNCDEF><VOID></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

first person in database in key order

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>INDI <FUNCTION>lastindi</FUNCTION></FUNCDEF><VOID></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

last person in database in key order

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>INDI <FUNCTION>nextindi</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INDI</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

next person in database in key order

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>INDI <FUNCTION>previndi</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INDI</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

previous person in database in key order

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><SYNOPSIS><COMMAND>spouses</COMMAND> (<REPLACEABLE>INDI</REPLACEABLE>, <REPLACEABLE>INDI</REPLACEABLE>, <REPLACEABLE>FAM</REPLACEABLE>, <REPLACEABLE>INT</REPLACEABLE>) { <REPLACEABLE>commands</REPLACEABLE> }</SYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

loop through all spouses of

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><SYNOPSIS><COMMAND>families</COMMAND> (<REPLACEABLE>INDI</REPLACEABLE>, <REPLACEABLE>FAM</REPLACEABLE>, <REPLACEABLE>INDI</REPLACEABLE>, <REPLACEABLE>INT</REPLACEABLE>) { <REPLACEABLE>commands</REPLACEABLE> }</SYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

loop through all families (as spouse) of

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><SYNOPSIS><COMMAND>forindi</COMMAND> (<REPLACEABLE>INDI</REPLACEABLE>, <REPLACEABLE>INT</REPLACEABLE>) { <REPLACEABLE>commands</REPLACEABLE> }</SYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

loop through all persons in database

</PARA>

</GLOSSDEF></GLOSSENTRY></GLOSSLIST>

<PARA>

These functions take a person as a parameter and return information about him or her.


</PARA>



<PARA>

<FUNCTION>Name</FUNCTION> returns the default name of a person; this is the name found on the first <STRUCTFIELD>1 NAME</STRUCTFIELD> line in the
person's record; the slashes are removed and the surname is made all capitals; <FUNCTION>name</FUNCTION> can take an
optional second parameter - if it is <RETURNVALUE>true</RETURNVALUE> the function acts as described above; if <RETURNVALUE>false</RETURNVALUE>, the surname is
kept exactly as it is in the record.


</PARA>



<PARA>

<FUNCTION>Fullname</FUNCTION> returns the name of a person in a variety of formats. If the second parameter is <RETURNVALUE>true</RETURNVALUE> the
surname is shown in upper case; otherwise the surname is as in the record. If the third parameter is
<RETURNVALUE>true</RETURNVALUE> the parts of the name are shown in the order as found in the record; otherwise the surname is given
first, followed by a comma, followed by the other name parts. The fourth parameter specifies the
maximum length field that can be used to show the name; various conversions occur if it is necessary to
shorten the name to fit this length.


</PARA>



<PARA>

<FUNCTION>Surname</FUNCTION> returns the surname of the person, as found in the first <STRUCTFIELD>1 NAME</STRUCTFIELD> line; the slashes are
removed. <FUNCTION>Givens</FUNCTION> returns the given names of the person in the same order and format as found in the
first <STRUCTFIELD>1 NAME</STRUCTFIELD> line of the record. <FUNCTION>Trimname</FUNCTION> returns the default name of the person trimmed to the
maximum character length given in the second variable.


</PARA>



<PARA>

<FUNCTION>Birth</FUNCTION>, <FUNCTION>death</FUNCTION>, <FUNCTION>baptism</FUNCTION> and <FUNCTION>burial</FUNCTION> return the first birth, death, baptism and burial event in the
person's record, respectively. An event is a level <STRUCTFIELD>1 GEDCOM</STRUCTFIELD> node. If there is no matching event these
functions return <RETURNVALUE>null</RETURNVALUE>.


</PARA>



<PARA>

<FUNCTION>Father</FUNCTION>, <FUNCTION>mother</FUNCTION>, <FUNCTION>nextsib</FUNCTION> and <FUNCTION>prevsib</FUNCTION> return the father, mother, next younger sibling and next older
sibling of the person, respectively. If the person has more than one father (mother) the <FUNCTION>father</FUNCTION>
(<FUNCTION>mother</FUNCTION>) function returns the first one. These functions return <RETURNVALUE>null</RETURNVALUE> if there is no person in the role.


</PARA>



<PARA>

<FUNCTION>Sex</FUNCTION> returns the person's sex as the string <RETURNVALUE>M</RETURNVALUE> if the person is male, <RETURNVALUE>F</RETURNVALUE> if the person is female, or <RETURNVALUE>U</RETURNVALUE> if the
sex of the person is not known. <FUNCTION>Male</FUNCTION> and <FUNCTION>female</FUNCTION> return <RETURNVALUE>true</RETURNVALUE> if the person is male or female,
respectively, or <RETURNVALUE>false</RETURNVALUE> if not.

</PARA>



<PARA>

<FUNCTION>Pn</FUNCTION> generates pronouns, useful when generating English text; the second parameter selects the type of
pronoun:<VARIABLELIST><VARLISTENTRY><TERM>0</TERM><LISTITEM>

<PARA>

He/She

</PARA>

</LISTITEM></VARLISTENTRY><VARLISTENTRY><TERM>1</TERM><LISTITEM>

<PARA>

he/she

</PARA>

</LISTITEM></VARLISTENTRY><VARLISTENTRY><TERM>2</TERM><LISTITEM>

<PARA>

His/Her

</PARA>

</LISTITEM></VARLISTENTRY><VARLISTENTRY><TERM>3</TERM><LISTITEM>

<PARA>

his/her

</PARA>

</LISTITEM></VARLISTENTRY><VARLISTENTRY><TERM>4</TERM><LISTITEM>

<PARA>

him/her

</PARA>

</LISTITEM></VARLISTENTRY></VARIABLELIST>

</PARA>



<PARA>

<FUNCTION>Nspouses</FUNCTION> returns the number of spouses the person has in the database, and <FUNCTION>nfamilies</FUNCTION> returns the
number of families the person is a parent/spouse in; these two values are not necessarily the same.
<FUNCTION>Parents</FUNCTION> returns the first family that the person is a child in.


</PARA>



<PARA>

<FUNCTION>Title</FUNCTION> returns the value of the first <STRUCTFIELD>1 TITL</STRUCTFIELD> line in the record. <FUNCTION>Key</FUNCTION> returns the key value of a person or
family; it there is a second parameter and it is non-null, the leading <LITERAL>I</LITERAL> or <LITERAL>F</LITERAL> will be stripped. <FUNCTION>Soundex</FUNCTION>
returns the Soundex code of the person.


</PARA>



<PARA>

<FUNCTION>Root</FUNCTION> and <FUNCTION>Inode</FUNCTION> return the root node of the person's <ACRONYM>GEDCOM</ACRONYM> node tree. Note that an <TYPE>INDI</TYPE> value is
not a <TYPE>NODE</TYPE> value. If you want to process the nodes within a person node tree, you must first use the
<FUNCTION>root</FUNCTION> or <FUNCTION>inode</FUNCTION> function to get the root of the person node tree. <FUNCTION>Root</FUNCTION> and <FUNCTION>inode</FUNCTION> are synonyms.


</PARA>



<PARA>

<FUNCTION>Indi</FUNCTION> returns the person who's key is passed as an argument; if no person has the key <FUNCTION>indi</FUNCTION> returns <RETURNVALUE>null</RETURNVALUE>.


</PARA>



<PARA>

<FUNCTION>Firstindi</FUNCTION>, <FUNCTION>nextindi</FUNCTION> and <FUNCTION>previndi</FUNCTION> allow you to iterate through all persons in the database. <FUNCTION>Firstindi</FUNCTION>
returns the first person in the database in key order. <FUNCTION>Nextindi</FUNCTION> returns the next person after the
argument person in key order. <FUNCTION>Previndi</FUNCTION> returns the previous person before the argument person in key
order.


</PARA>



<PARA>

<COMMAND>Spouses</COMMAND> is an iterator that loops through each spouse a person has. The first argument is a person. The
second argument is a person variable that iterates through the first person's spouses. The third
argument is a family variable that iterates through the families the person and each spouse are in.
The fourth argument is an integer variable that counts the iterations.


</PARA>



<PARA>

<COMMAND>Families</COMMAND> is an iterator that loops through the families a person was a spouse/parent in. The first
argument is a person. The second argument is a family variable that iterates through the families the
first person was a spouse/parent in. The third argument iterates through the spouses from the families;
if there is no spouse in a particular family, the variable is set to null for that iteration. The fourth
argument is an integer variable that counts the iterations.


</PARA>



<PARA>

<COMMAND>Forindi</COMMAND> is an iterator that loops through every person in the database in ascending key order. Its first
parameter is a variable that iterates through the persons; its second parameter is an integer counter
variable that counts the persons starting at one.

</PARA>



</SECT1>



<SECT1>



<TITLE>

Family Functions

</TITLE>

<GLOSSLIST><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>EVENT <FUNCTION>marriage</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>FAM</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

first marriage event of

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>INDI <FUNCTION>husband</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>FAM</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

first husband/father of

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>INDI <FUNCTION>wife</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>FAM</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

first wife/mother of

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>INT <FUNCTION>nchildren</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>FAM</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

number of children in

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>INDI <FUNCTION>firstchild</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>FAM</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

first child of

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>INDI <FUNCTION>lastchild</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>FAM</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

last child of

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>key</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>FAM|INDI</PARAMETER><PARAMETER><OPTIONAL>BOOL</OPTIONAL></PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

internal key of (works for persons also)

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>NODE <FUNCTION>fnode</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>FAM</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

root GEDCOM node of

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>NODE <FUNCTION>root</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>FAM</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

root GEDCOM node of

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>FAM <FUNCTION>fam</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>STRING</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

find family from key

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>FAM <FUNCTION>firstfam</FUNCTION></FUNCDEF><VOID></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

first family in database in key order

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>FAM <FUNCTION>lastfam</FUNCTION></FUNCDEF><VOID></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

last family in database in key order

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>FAM <FUNCTION>nextfam</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>FAM</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

next family in database in key order

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>FAM <FUNCTION>prevfam</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>FAM</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

previous family in database in key order

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><SYNOPSIS><COMMAND>children</COMMAND> (<REPLACEABLE>FAM</REPLACEABLE>, <REPLACEABLE>INDI_V</REPLACEABLE>, <REPLACEABLE>INT_V</REPLACEABLE>) { <REPLACEABLE>commands</REPLACEABLE> }</SYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

loop through children of family

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><SYNOPSIS><COMMAND>forfam</COMMAND> (<REPLACEABLE>FAM_V</REPLACEABLE>, <REPLACEABLE>INT_V</REPLACEABLE>) { <REPLACEABLE>commands</REPLACEABLE> }</SYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

loop through all families in database

</PARA>

</GLOSSDEF></GLOSSENTRY></GLOSSLIST>

<PARA>

These functions take a family as an argument and return information about it.


</PARA>



<PARA>

<FUNCTION>Marriage</FUNCTION> returns the first marriage event found in the family record, if any; it returns <RETURNVALUE>null</RETURNVALUE> if there is
no marriage event.


</PARA>



<PARA>

<FUNCTION>Husband</FUNCTION> returns the first husband/father of the family, if any; and <FUNCTION>wife</FUNCTION> returns the first
wife/mother of the family, if any. Each returns <RETURNVALUE>null</RETURNVALUE> if the requested person is not in the family.


</PARA>



<PARA>

<FUNCTION>Nchildren</FUNCTION> returns the number of children in the family.


</PARA>



<PARA>

<FUNCTION>Firstchild</FUNCTION> and <FUNCTION>lastchild</FUNCTION> return the first child and last child in a family, respectively.


</PARA>



<PARA>

<FUNCTION>Key</FUNCTION> was described in the section on person functions.


</PARA>



<PARA>

<FUNCTION>Root</FUNCTION> and <FUNCTION>fnode</FUNCTION> return the root node of a family <ACRONYM>GEDCOM</ACRONYM> node tree. Note that a <TYPE>FAM</TYPE> value is not a
<TYPE>NODE</TYPE> value. If you want to process the nodes within a family node tree, you must first use <FUNCTION>root</FUNCTION> or
<FUNCTION>fnode</FUNCTION> function to get the root of the family node tree. <FUNCTION>Root</FUNCTION> and <FUNCTION>fnode</FUNCTION> are synonyms.


</PARA>



<PARA>

<FUNCTION>Fam</FUNCTION> returns the family who's key is passed as an argument; if no family has the key <FUNCTION>fam</FUNCTION> returns <RETURNVALUE>null</RETURNVALUE>.


</PARA>



<PARA>

<FUNCTION>Firstfam</FUNCTION>, <FUNCTION>nextfam</FUNCTION> and <FUNCTION>prevfam</FUNCTION> allow you to iterate through all families in the database. <FUNCTION>Firstfam</FUNCTION>
returns the first family in the database in key order. <FUNCTION>Nextfam</FUNCTION> returns the next family after the
argument family in key order. <FUNCTION>Prevfam</FUNCTION> returns the previous family before the argument family in key
order.


</PARA>



<PARA>

<COMMAND>Children</COMMAND> is an iterator that loops through the children in a family. Its first parameter is a family
expression; its second parameter is a variable that iterates through each child; its third parameter is
an integer counter variable that counts the children starting at one. These two variables may be used
within the loop body.


</PARA>



<PARA>

<COMMAND>Forfam</COMMAND> is an iterator that loops through every family in the database in ascending key order. Its first
parameter is a variable that iterates through the families; its second parameter is an integer counter
variable that counts the families starting at one.

</PARA>



</SECT1>



<SECT1>



<TITLE>

List Functions

</TITLE>

<GLOSSLIST><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>list</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>LIST_V</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

declare a list

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>BOOL <FUNCTION>empty</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>LIST</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

check if list is empty

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>list</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>LIST_V</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

declare a list

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>enqueue</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>LIST</PARAMETER><PARAMETER>ANY</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

enqueue element on list

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>ANY <FUNCTION>dequeue</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>LIST</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

dequeue and return element from list

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>requeue</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>LIST</PARAMETER><PARAMETER>ANY</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

requeue an element on list

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>push</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>LIST</PARAMETER><PARAMETER>ANY</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

push element on list

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>ANY <FUNCTION>pop</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>LIST</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

pop and return element from list

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>setel</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>LIST</PARAMETER><PARAMETER>INT</PARAMETER><PARAMETER>ANY</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

array element assignment

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>ANY <FUNCTION>getel</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>LIST</PARAMETER><PARAMETER>INT</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

array element selection

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><SYNOPSIS><COMMAND>forlist</COMMAND> (<REPLACEABLE>LIST</REPLACEABLE>, <REPLACEABLE>ANY_V</REPLACEABLE>, <REPLACEABLE>INT_V</REPLACEABLE>) { <REPLACEABLE>commands</REPLACEABLE> }</SYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

loop through all elements of list

</PARA>

</GLOSSDEF></GLOSSENTRY></GLOSSLIST>

<PARA>

<APPLICATION>LifeLines</APPLICATION> provides general purpose lists that can be accessed as queues, stacks or arrays. A list must be
declared with the <FUNCTION>list</FUNCTION> function before it can be used.


</PARA>



<PARA>

A list can have any number of elements. <FUNCTION>Empty</FUNCTION> returns <RETURNVALUE>true</RETURNVALUE> if the list has no elements and <RETURNVALUE>false</RETURNVALUE>
otherwise. <FUNCTION>Length</FUNCTION> returns the length of the list. The only parameter to both is a list.


</PARA>



<PARA>

<FUNCTION>Enqueue</FUNCTION>, <FUNCTION>dequeue</FUNCTION> and <FUNCTION>requeue</FUNCTION> provide queue access to a list. <FUNCTION>Enqueue</FUNCTION> adds an element to the back of a
queue, <FUNCTION>dequeue</FUNCTION> removes and returns the element from the front of a queue, and <FUNCTION>requeue</FUNCTION> adds an element
to the front of a queue. The first parameter to all three is a list, and the second parameter to <FUNCTION>enqueue</FUNCTION>
and <FUNCTION>requeue</FUNCTION> is the value to be added to the queue and can be any value.


</PARA>



<PARA>

<FUNCTION>Push</FUNCTION> and <FUNCTION>pop</FUNCTION> provide stack access to a list. <FUNCTION>Push</FUNCTION> pushes an element on the stack, and <FUNCTION>pop</FUNCTION> removes
and returns the most recently pushed element from the stack. The first parameter to both is a list, and
the second parameter to <FUNCTION>push</FUNCTION> is the value to be pushed on the stack and can be of any type.


</PARA>



<PARA>

<FUNCTION>Setel</FUNCTION> and <FUNCTION>getel</FUNCTION> provide array access to a list. <FUNCTION>Setel</FUNCTION> sets a value of an array element, and <FUNCTION>getel</FUNCTION>
returns the value of an array element. The first parameter to both is a list; the second parameter to both
is an integer index into the array; and the third parameter to <FUNCTION>setel</FUNCTION> is the value to assign to the array
element and can be of any type. Array elements are indexed starting at one. Unassigned elements are
assumed to be <RETURNVALUE>null</RETURNVALUE> (<RETURNVALUE>0</RETURNVALUE>). Arrays automatically grow in size to accommodate the largest index value that
is used.


</PARA>



<PARA>

<COMMAND>Forlist</COMMAND> is an iterator that loops through the element in a list. Its first parameter is a <TYPE>LIST</TYPE> expression;
its second parameter is a variable that iterates through the list elements; and its third parameter is an
integer counter variable that counts the list elements starting at one.

</PARA>



</SECT1>



<SECT1>



<TITLE>

Table Functions

</TITLE>

<GLOSSLIST><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>table</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>TABLE_V</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

declare a table

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>insert</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>TABLE</PARAMETER><PARAMETER>STRING</PARAMETER><PARAMETER>ANY</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

insert entry in table

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>ANY <FUNCTION>lookup</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>TABLE</PARAMETER><PARAMETER>STRING</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

lookup and return entry from table

</PARA>

</GLOSSDEF></GLOSSENTRY></GLOSSLIST>

<PARA>

These functions provide general purpose, keyed tables. A table must be declared with the <FUNCTION>table</FUNCTION>
function before it can be used.


</PARA>



<PARA>

<FUNCTION>Insert</FUNCTION> adds an object and its key to a table. Its first parameter is a table; the second parameter is the
object's key; and the third parameter is the object itself. The key must be a string and the object can be
any value. If there already is an object in the table with that key, the old object is replaced with the
new.


</PARA>



<PARA>

<FUNCTION>Lookup</FUNCTION> retrieves an object from a table. Its first parameter is a table, and the second parameter is the
object's key. The function returns the object with that key from the table; if there is no such object, <RETURNVALUE>null</RETURNVALUE>
is returned.

</PARA>



</SECT1>



<SECT1>



<TITLE>

GEDCOM Node Functions

</TITLE>

<GLOSSLIST><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>xref</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>NODE</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

cross reference index of

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>tag</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>NODE</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

tag of

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>value</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>NODE</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

value of

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>NODE <FUNCTION>parent</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>NODE</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

parent node of

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>NODE <FUNCTION>child</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>NODE</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

first child of

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>NODE <FUNCTION>sibling</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>NODE</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

next sibling of

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>NODE <FUNCTION>savenode</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>NODE</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

copy a node structure

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><SYNOPSIS><COMMAND>fornodes</COMMAND> (<REPLACEABLE>NODE</REPLACEABLE>, <REPLACEABLE>NODE_V</REPLACEABLE>) { <REPLACEABLE>commands</REPLACEABLE> }</SYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

loop through child nodes

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><SYNOPSIS><COMMAND>traverse</COMMAND> (<REPLACEABLE>NODE</REPLACEABLE>, <REPLACEABLE>NODE_V</REPLACEABLE>, <REPLACEABLE>INT_V</REPLACEABLE>) { <REPLACEABLE>commands</REPLACEABLE> }</SYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

loop through all descendent nodes

</PARA>

</GLOSSDEF></GLOSSENTRY></GLOSSLIST>

<PARA>

These functions provide access to the components of a <ACRONYM>GEDCOM</ACRONYM> node. All take a <ACRONYM>GEDCOM</ACRONYM> node as their
only parameter, and each returns a different value associated with the node.


</PARA>



<PARA>

<FUNCTION>Xref</FUNCTION> returns the cross reference index of the node, if any; <FUNCTION>tag</FUNCTION> returns the tag of the node; and <FUNCTION>value</FUNCTION>
returns the value of the node, if any. If there is no cross reference, <FUNCTION>xref</FUNCTION> returns <RETURNVALUE>null</RETURNVALUE>; if there is no value,
value returns <RETURNVALUE>null</RETURNVALUE>.


</PARA>



<PARA>

<FUNCTION>Parent</FUNCTION> returns the parent node of the node, if any; <FUNCTION>child</FUNCTION> returns the first child node of the node, if any;
and <FUNCTION>sibling</FUNCTION> returns the next sibling node of the node, if any. Whenever there is no such related node,
these functions return <RETURNVALUE>null</RETURNVALUE>. These three functions allow simple navigation through a <ACRONYM>GEDCOM</ACRONYM> node
tree.


</PARA>



<PARA>

<FUNCTION>Savenode</FUNCTION> makes a copy of the node, and the substructure of nodes below the node, that is passed to it.
Beware: the memory used to make the copy is never returned to the system.


</PARA>



<PARA>

<COMMAND>Fornodes</COMMAND> is an iterator that loops through the child nodes of a <ACRONYM>GEDCOM</ACRONYM> node. Its first argument is a
node expression, and its second parameter is a variable that iterates through each direct child node of
the first node.


</PARA>



<PARA>

<COMMAND>Traverse</COMMAND> is an iterator providing a general method for traversing <ACRONYM>GEDCOM</ACRONYM> trees. Its first parameter is
a node expression; its second parameter is a variable that iterates over every node under the first node
in a top down, left to right manner; and its third parameter is a variable that is set to the level of the
current node in the iteration.

</PARA>



</SECT1>



<SECT1>



<TITLE>

Event and Date Functions

</TITLE>

<GLOSSLIST><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>date</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>EVENT</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

date of, value of first <STRUCTFIELD>DATE</STRUCTFIELD> line

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>place</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>EVENT</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

place of, value of first <STRUCTFIELD>PLAC</STRUCTFIELD> line

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>year</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>EVENT</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

year or, 1st string of 3-4 digits in 1st <STRUCTFIELD>DATE</STRUCTFIELD> line

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>long</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>EVENT</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

date and place, values of 1st <STRUCTFIELD>DATE</STRUCTFIELD> and <STRUCTFIELD>PLAC</STRUCTFIELD> lines

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>short</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>EVENT</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

date and place of, abbreviated from

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>EVENT <FUNCTION>gettoday</FUNCTION></FUNCDEF><VOID></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

returns the `event' of the current date

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>dayformat</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INT</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

set day format for stddate calls

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>monthformat</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INT</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

set month format for stddate calls

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>dateformat</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INT</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

set date format for stddate calls

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>stddate</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>EVENT</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

date of, in current format

</PARA>

</GLOSSDEF></GLOSSENTRY></GLOSSLIST>

<PARA>

These functions extract information about the dates and places of events.


</PARA>



<PARA>

<FUNCTION>Date</FUNCTION> returns the value of the first <STRUCTFIELD>DATE</STRUCTFIELD> line in an event, a node in a <ACRONYM>GEDCOM</ACRONYM> record tree. <FUNCTION>Date</FUNCTION>
finds the first <STRUCTFIELD>DATE</STRUCTFIELD> line one level deeper than the event node. <FUNCTION>Place</FUNCTION> returns the value of the first
<STRUCTFIELD>PLAC</STRUCTFIELD> line in an event. <FUNCTION>Year</FUNCTION> returns the first three or four digit number in the value of the first <STRUCTFIELD>DATE</STRUCTFIELD>
line in an event; this number is assumed to be the year of the event.


</PARA>



<PARA>

<FUNCTION>Long</FUNCTION> returns the verbatim values of the first <STRUCTFIELD>DATE</STRUCTFIELD> and <STRUCTFIELD>PLAC</STRUCTFIELD> lines in an event, catenated together
and separated by a comma. <FUNCTION>Short</FUNCTION> abbreviates information from the first <STRUCTFIELD>DATE</STRUCTFIELD> and <STRUCTFIELD>PLAC</STRUCTFIELD> lines, catenates the shortened information together with a comma separator and returns it. An abbreviated
date is its year; an abbreviated place is the last component in the value, further abbreviated if the
component has an entry in the place abbreviation table.


</PARA>



<PARA>

<FUNCTION>Gettoday</FUNCTION> creates an event that has today's date in the <STRUCTFIELD>DATE</STRUCTFIELD> line.


</PARA>



<PARA>

The last four functions are used to format dates in a variety of ways. <FUNCTION>Dayformat</FUNCTION>, <FUNCTION>monthformat</FUNCTION>, and
<FUNCTION>dateformat</FUNCTION> select style options for formatting the day, month, and overall date structure; <FUNCTION>stddate</FUNCTION>
returns dates in the selected style. The day format codes passed to <FUNCTION>dayformat</FUNCTION> are:<VARIABLELIST><VARLISTENTRY><TERM>0</TERM><LISTITEM>

<PARA>

leave space before single digit days

</PARA>

</LISTITEM></VARLISTENTRY><VARLISTENTRY><TERM>1</TERM><LISTITEM>

<PARA>

use leading 0 before single digit days

</PARA>

</LISTITEM></VARLISTENTRY><VARLISTENTRY><TERM>2</TERM><LISTITEM>

<PARA>

no space or leading 0 before single digit days

</PARA>

</LISTITEM></VARLISTENTRY></VARIABLELIST>

</PARA>



<PARA>

The month format codes passed to <FUNCTION>monthformat</FUNCTION> are:<VARIABLELIST><VARLISTENTRY><TERM>0</TERM><LISTITEM>

<PARA>

number with space before single digit months

</PARA>

</LISTITEM></VARLISTENTRY><VARLISTENTRY><TERM>1</TERM><LISTITEM>

<PARA>

number with leading zero before single digit months

</PARA>

</LISTITEM></VARLISTENTRY><VARLISTENTRY><TERM>2</TERM><LISTITEM>

<PARA>

number with no space or zero before single digit months

</PARA>

</LISTITEM></VARLISTENTRY><VARLISTENTRY><TERM>3</TERM><LISTITEM>

<PARA>

upper case abbreviation (eg, JAN, FEB)

</PARA>

</LISTITEM></VARLISTENTRY><VARLISTENTRY><TERM>4</TERM><LISTITEM>

<PARA>

capitalized abbreviation (eg, Jan, Feb)

</PARA>

</LISTITEM></VARLISTENTRY><VARLISTENTRY><TERM>5</TERM><LISTITEM>

<PARA>

upper case full word (eg, JANUARY, FEBRUARY)

</PARA>

</LISTITEM></VARLISTENTRY><VARLISTENTRY><TERM>6</TERM><LISTITEM>

<PARA>

capitalized full word (eg, January, February)

</PARA>

</LISTITEM></VARLISTENTRY></VARIABLELIST>

</PARA>



<PARA>

The full date formats passed to <FUNCTION>stddate</FUNCTION> are:<VARIABLELIST><VARLISTENTRY><TERM>0</TERM><LISTITEM>

<PARA>

da mo yr

</PARA>

</LISTITEM></VARLISTENTRY><VARLISTENTRY><TERM>1</TERM><LISTITEM>

<PARA>

mo da, yr

</PARA>

</LISTITEM></VARLISTENTRY><VARLISTENTRY><TERM>2</TERM><LISTITEM>

<PARA>

mo/da/yr

</PARA>

</LISTITEM></VARLISTENTRY><VARLISTENTRY><TERM>3</TERM><LISTITEM>

<PARA>

da/mo/yr

</PARA>

</LISTITEM></VARLISTENTRY><VARLISTENTRY><TERM>4</TERM><LISTITEM>

<PARA>

mo-da-yr

</PARA>

</LISTITEM></VARLISTENTRY><VARLISTENTRY><TERM>5</TERM><LISTITEM>

<PARA>

da-mo-yr

</PARA>

</LISTITEM></VARLISTENTRY><VARLISTENTRY><TERM>6</TERM><LISTITEM>

<PARA>

modayr

</PARA>

</LISTITEM></VARLISTENTRY><VARLISTENTRY><TERM>7</TERM><LISTITEM>

<PARA>

damoyr

</PARA>

</LISTITEM></VARLISTENTRY><VARLISTENTRY><TERM>8</TERM><LISTITEM>

<PARA>

yr mo da

</PARA>

</LISTITEM></VARLISTENTRY><VARLISTENTRY><TERM>9</TERM><LISTITEM>

<PARA>

yr/mo/da

</PARA>

</LISTITEM></VARLISTENTRY><VARLISTENTRY><TERM>10</TERM><LISTITEM>

<PARA>

yr-mo-da

</PARA>

</LISTITEM></VARLISTENTRY><VARLISTENTRY><TERM>11</TERM><LISTITEM>

<PARA>

yrmoda

</PARA>

</LISTITEM></VARLISTENTRY></VARIABLELIST>

</PARA>



</SECT1>



<SECT1>



<TITLE>

Value Extraction Functions

</TITLE>

<GLOSSLIST><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>extractdate</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>NODE</PARAMETER><PARAMETER>INT_V</PARAMETER><PARAMETER>INT_V</PARAMETER><PARAMETER>INT_V</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

extract a date

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>extractnames</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>NODE</PARAMETER><PARAMETER>LIST_V</PARAMETER><PARAMETER>INT_V</PARAMETER><PARAMETER>INT_V</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

extract a name

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>extractplaces</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>NODE</PARAMETER><PARAMETER>LIST_V</PARAMETER><PARAMETER>INT_V</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

extract a place

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>extracttokens</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>STRING</PARAMETER><PARAMETER>LIST_V</PARAMETER><PARAMETER>INT_V</PARAMETER><PARAMETER>STRING</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

extract tokens

</PARA>

</GLOSSDEF></GLOSSENTRY></GLOSSLIST>

<PARA>

Value extraction functions read the values of certain lines and return those values in extracted form.


</PARA>



<PARA>

<FUNCTION>Extractdate</FUNCTION> extracts date values from either an event node or <STRUCTFIELD>DATE</STRUCTFIELD> node. The first parameter must be
a node; if its tag is <STRUCTFIELD>DATE</STRUCTFIELD>, the date is extracted from the value of that node; if its tag is not <STRUCTFIELD>DATE</STRUCTFIELD>, the
date is extracted from the first <STRUCTFIELD>DATE</STRUCTFIELD> line one level below the argument node. The remaining three
arguments are variables. The first is assigned the integer value of the extracted day; the second is
assigned the integer value of the extracted month; and the third is assigned the integer value of the
extracted year.


</PARA>



<PARA>

<FUNCTION>Extractnames</FUNCTION> extracts name components from a <STRUCTFIELD>NAME</STRUCTFIELD> line. Its first argument is either an <STRUCTFIELD>INDI</STRUCTFIELD> or a
<STRUCTFIELD>NAME</STRUCTFIELD> node. If it is a <STRUCTFIELD>NAME</STRUCTFIELD> line, the components are extracted from the value of that node; if it is an
<STRUCTFIELD>INDI</STRUCTFIELD> line, the components are extracted from the value of the first <STRUCTFIELD>NAME</STRUCTFIELD> line in the person record.
The second argument is a list that will hold the extracted components. The third argument is an integer
variable that is set to the number of extracted components. The fourth argument is a variable that is set
to the index (starting at one) of the surname component; the <LITERAL>/</LITERAL> characters are removed from around the
surname component. If there is no surname this argument variable is set to zero.


</PARA>



<PARA>

	<FUNCTION>Extractplaces</FUNCTION> extracts place components
	from a <STRUCTFIELD>PLAC</STRUCTFIELD> node. The first
	argument is a node; if its tag is
	<STRUCTFIELD>PLAC</STRUCTFIELD>, the places are extracted from
	the value of the node; if its tag is not
	<STRUCTFIELD>PLAC</STRUCTFIELD>, places are extracted from the
	first <STRUCTFIELD>PLAC</STRUCTFIELD> line one level below the
	argument node. The second parameter is a list that will hold
	the extracted components. The third argument is an integer
	variable that is set to the number of extracted
	components. Place components are defined by the
	comma-separated portions of the
	<STRUCTFIELD>PLAC</STRUCTFIELD> value; leading and trailing
	white space is removed from the components, while all internal
	white space is retained.

</PARA>



<PARA>

	<FUNCTION>Extracttokens</FUNCTION> extracts tokens from a
	string and places them in a list. The first argument is the
	string to extract tokens from. The second argument is the list
	to hold the tokens. The third argument is an integer variable
	that is set to the number of tokens extracted. The fourth
	parameter is the string of deliminater characters that
	<FUNCTION>extracttokens</FUNCTION> uses to break the input
	string into tokens.

</PARA>



</SECT1>



<SECT1>



<TITLE>

User Interaction Functions

</TITLE>

<GLOSSLIST><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>getindi</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INDI_V</PARAMETER><PARAMETER><OPTIONAL>STRING</OPTIONAL></PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

identify person through user interface

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>getindiset</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>SET_V</PARAMETER><PARAMETER><OPTIONAL>STRING</OPTIONAL></PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

identify set of persons through user interface

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>getfam</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>FAM_V</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

identify family through user interface

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>getint</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INT_V</PARAMETER><PARAMETER><OPTIONAL>STRING</OPTIONAL></PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

get integer through user interface

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>getstr</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>STRING_V</PARAMETER><PARAMETER><OPTIONAL>STRING</OPTIONAL></PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

get string through user interface

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>INDI <FUNCTION>choosechild</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INDI|FAM</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

select child of person/family thru user interface

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>FAM <FUNCTION>choosefam</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INDI</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

select family person is in as spouse

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>INDI <FUNCTION>chooseindi</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>SET</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

select person from set of persons

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>INDI <FUNCTION>choosespouse</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INDI</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

select spouse of person

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>SET <FUNCTION>choosesubset</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>SET</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

select a subset of persons from set of persons

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>INT <FUNCTION>menuchoose</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>LIST</PARAMETER><PARAMETER><OPTIONAL>STRING</OPTIONAL></PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

select from a list of options

</PARA>

</GLOSSDEF></GLOSSENTRY></GLOSSLIST>

<PARA>

These functions interact with the user to get information needed by the program.


</PARA>



<PARA>

<FUNCTION>Getindi</FUNCTION> asks the user to identify a person. The first argument is a variable that is set to the person.
The second is an optional string to use as a prompt. <FUNCTION>Getindiset</FUNCTION> asks the user to identify a set of persons.
<FUNCTION>Getfam</FUNCTION> asks the user identify a family. <FUNCTION>Getint</FUNCTION> and <FUNCTION>getstr</FUNCTION> ask the user enter an integer and string,
respectively.


</PARA>



<PARA>

<FUNCTION>Choosechild</FUNCTION> asks the user select a child of a family or person; its single argument is a person or family;
it return the child. <FUNCTION>Choosefam</FUNCTION> has the user select a family that a person is in as a spouse; its argument
is a person; it returns the family. <FUNCTION>Chooseindi</FUNCTION> has the user select one person from a set of persons; its
argument in a set of persons; it returns the chosen person. <FUNCTION>Choosespouse</FUNCTION> has the user select a spouse of a
person; its argument is a person; it returns the chosen spouse. <FUNCTION>Choosesubset</FUNCTION> has the user select a subset of
persons from a set of persons; its argument is the chosen subset.


</PARA>



<PARA>

<FUNCTION>Menuchoose</FUNCTION> allows the user to select from an arbitrary menu. The first argument is a list of strings
making up the items in the menu; the second, optional argument is a prompt string for the menu;
<FUNCTION>menuchoose</FUNCTION> returns the integer index of the item selected by the user; if the user doesn't select an item,
<RETURNVALUE>zero</RETURNVALUE> is return.

</PARA>



</SECT1>



<SECT1>



<TITLE>

String Functions

</TITLE>

<GLOSSLIST><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>lower</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>STRING</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

convert to lower case

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>upper</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>STRING</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

convert to upper case

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>capitalize</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>STRING</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

capitalize first letter

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>trim</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>STRING</PARAMETER><PARAMETER>INT</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

trim to length

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>rjustify</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>STRING</PARAMETER><PARAMETER>INT</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

right justify in field

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>save</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>STRING</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

save and return copy of string

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>strsave</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>STRING</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

same as save function

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>concat</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>STRING</PARAMETER><PARAMETER><OPTIONAL>STRING</OPTIONAL></PARAMETER><PARAMETER><OPTIONAL>...</OPTIONAL></PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

catenate two strings

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>strconcat</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>STRING</PARAMETER><PARAMETER><OPTIONAL>STRING</OPTIONAL></PARAMETER><PARAMETER><OPTIONAL>...</OPTIONAL></PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

catenate two strings

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>INT <FUNCTION>strlen</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>STRING</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

number of characters in string

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>substring(</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>STRING</PARAMETER><PARAMETER>INT</PARAMETER><PARAMETER>INT</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

substring function

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>INT <FUNCTION>index</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>STRING</PARAMETER><PARAMETER>STRING</PARAMETER><PARAMETER>INT</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

index function

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>d</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INT</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

number as decimal string

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>card</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INT</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

number in cardinal form (<LITERAL>one, two, ...</LITERAL>)

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>ord</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INT</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

number in ordinal form (<LITERAL>first, second, ...</LITERAL>)

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>alpha</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INT</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

convert number to Latin letter (<LITERAL>a, b, ...</LITERAL>)

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>roman</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INT</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

number in Roman numeral form (<LITERAL>i, ii, ...</LITERAL>)

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>strsoundex</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>STRING</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

find SOUNDEX value of arbitrary string

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>INT <FUNCTION>strtoint</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>STRING</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

convert numeric string to integer

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>INT <FUNCTION>atoi</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>STRING</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

convert numeric string to integer

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>INT <FUNCTION>strcmp</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>STRING</PARAMETER><PARAMETER>STRING</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

general string compare

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>BOOL <FUNCTION>eqstr</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>STRING</PARAMETER><PARAMETER>STRING</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

compare strings for equality

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>BOOL <FUNCTION>nestr</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>STRING</PARAMETER><PARAMETER>STRING</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

compare strings for inequality

</PARA>

</GLOSSDEF></GLOSSENTRY></GLOSSLIST>

<PARA>

These functions provide string handling. Prior to version 3.0.6, many of them used an approach to memory management
chosen for absolute minimal memory footprint. A function using this approach constructed its output string in its own string
buffer, reusing that buffer each time it was called. When a function using this approach returned a string
value it returned its buffer. In consequence the strings returned by these functions were to be either used or
saved before the function was called again.

</PARA>

<PARA>

By the release of version 3.0.6, all string values are local copies, and the <FUNCTION>save</FUNCTION> and 
<FUNCTION>strsave</FUNCTION> functions should be entirely unnecessary.

</PARA>


<PARA>

<FUNCTION>Lower</FUNCTION> and <FUNCTION>upper</FUNCTION> convert the letters in their arguments to lower or upper case, respectively.
<FUNCTION>Capitalize</FUNCTION> converts the first character of the argument, if it is a letter, to upper case. <FUNCTION>Lower</FUNCTION> and
<FUNCTION>upper</FUNCTION> historically used the buffer return method; <FUNCTION>capitalize</FUNCTION> operates on and returns its argument.


</PARA>



<PARA>

<FUNCTION>Trim</FUNCTION> shortens a string to the length specified by the second parameter. If the string is already of that
length or shorter the string is not changed. <FUNCTION>Rjustify</FUNCTION> right justifies a string into another string of the
length specified by the second parameter. If the original string is shorter than the justified string,
blanks are inserted to the left of the original string; if the string is longer than the justified string, the
original string is truncated on the right. <FUNCTION>Trim</FUNCTION> historically used the buffer return method; <FUNCTION>rjustify</FUNCTION> creates and returns
a new string.


</PARA>



<PARA>

<FUNCTION>Save</FUNCTION> creates a copy of the argument string and returns it. This function is required because built-in
functions that return strings use the buffer return method; if a string is to be used repeatedly or long after
it is returned from a function, it should first be saved by using the <FUNCTION>save</FUNCTION> function. <FUNCTION>Strsave</FUNCTION> is the same
function as <FUNCTION>save</FUNCTION>. With version 3.0.6 or later, this should be unnecessary.


</PARA>



<PARA>

<FUNCTION>Concat</FUNCTION> and <FUNCTION>strconcat</FUNCTION> catenate strings and return the result. They are identical functions. They may
take two to 32 string arguments; null arguments are allowed. The arguments are catenated together into
a single, newly allocated string, which is returned.


</PARA>



<PARA>

<FUNCTION>Strlen</FUNCTION> returns the length of the string argument.


</PARA>



<PARA>

<FUNCTION>Substring</FUNCTION> returns a substring of the first argument string. The second and third arguments are the
indices of the first and last characters in the argument string to use to form the substring. The indexes are relative one.
<FUNCTION>Substring</FUNCTION> historically used the buffer return method.

</PARA>



<PARA>

<FUNCTION>Index</FUNCTION> returns the character index of the nth occurrence of a substring within a string. The index is the
relative one character offset to the beginning of the substring. The first argument is the string; the
second argument is the substring; and the third argument is the occurrence number.


</PARA>



<PARA>

<FUNCTION>D</FUNCTION>, <FUNCTION>card</FUNCTION>, <FUNCTION>ord</FUNCTION>, <FUNCTION>alpha</FUNCTION> and <FUNCTION>roman</FUNCTION> convert integers to strings. <FUNCTION>D</FUNCTION> converts an integer to a numeric string;
<FUNCTION>card</FUNCTION> converts an integer to a cardinal number string (eg, <LITERAL>one, two, three</LITERAL>); <FUNCTION>ord</FUNCTION> converts an integer to
an ordinal number (eg, <LITERAL>first, second, third</LITERAL>); <FUNCTION>alpha</FUNCTION> converts an integer to a letter (eg, <LITERAL>a, b, c</LITERAL>); and
<FUNCTION>roman</FUNCTION> converts an integer to a Roman numeral (eg, <LITERAL>i, ii, iii</LITERAL>).


</PARA>



<PARA>

<FUNCTION>Strsoundex</FUNCTION> converts an arbitrary string to a SOUNDEX value. Non-ASCII text characters are ignored
in the string.


</PARA>



<PARA>

<FUNCTION>Strtoint</FUNCTION> converts a numeric string to an integer. <FUNCTION>Atoi</FUNCTION> is identical to <FUNCTION>strtoint</FUNCTION>.


</PARA>



<PARA>

<FUNCTION>Strcmp</FUNCTION> compares two strings and returns an integer that is less than zero, equal to zero, or greater than
zero, if, respectively, the first string is lexicographically less than, equal to, or greater than the second
string. <FUNCTION>Eqstr</FUNCTION> and <FUNCTION>nestr</FUNCTION> return whether two strings are equal or not equal, respectively.
<FUNCTION>Strcmp</FUNCTION>, <FUNCTION>Eqstr</FUNCTION>, and <FUNCTION>nestr</FUNCTION> all treat null strings as empty strings,
which is to say they pretend that a null string is actually "". This means that all null and empty strings compare as equal.

</PARA>



</SECT1>



<SECT1>



<TITLE>

Output Mode Functions

</TITLE>

<GLOSSLIST><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>linemode</FUNCTION></FUNCDEF><VOID></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

use line output mode

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>pagemode</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INT</PARAMETER><PARAMETER>INT</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

use page output mode with given page size

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>col</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INT</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

position to column in output

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>row</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INT</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

position to row in output

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>pos</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INT</PARAMETER><PARAMETER>INT</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

position to (row, col) coordinate in output

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>pageout</FUNCTION></FUNCDEF><VOID></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

output page buffer

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>nl</FUNCTION></FUNCDEF><VOID></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

newline character

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>sp</FUNCTION></FUNCDEF><VOID></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

space character

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>qt</FUNCTION></FUNCDEF><VOID></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

double quote character

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>newfile</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>STRING</PARAMETER><PARAMETER>BOOL</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

send program output to this file

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>outfile</FUNCTION></FUNCDEF><VOID></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

return name of current program output file

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>copyfile</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>STRING</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

copy file contents to program output file

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>print</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>STRING</PARAMETER><PARAMETER><OPTIONAL>STRING</OPTIONAL></PARAMETER><PARAMETER><OPTIONAL>...</OPTIONAL></PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

print string to standard output window

</PARA>

</GLOSSDEF></GLOSSENTRY></GLOSSLIST>

<PARA>

Reports can be generated in two modes, line mode and page mode. <FUNCTION>Linemode</FUNCTION> selects line mode and
<FUNCTION>pagemode</FUNCTION> selects page mode; line mode is the default. The first parameter to <FUNCTION>pagemode</FUNCTION> is the number
of rows per page; the second parameter is the number of columns per page. When in the line mode report
output is written directly to the output file as the program runs, line by line. When in page mode output
is buffered into pages which are written to the output file when <FUNCTION>pageout</FUNCTION> is called. Page mode is useful
for generating charts (eg, pedigree charts or box charts) where it is convenient to compute the two-dimensional
location of output.


</PARA>



<PARA>

<FUNCTION>Col</FUNCTION> positions output to the given column. If the current column is greater than the argument, col
positions output to the given column on the next line. <FUNCTION>Col</FUNCTION> works in both modes.


</PARA>



<PARA>

<FUNCTION>Row</FUNCTION> positions output to the first character in the given row; <FUNCTION>row</FUNCTION> can only be used in page mode.


</PARA>



<PARA>

<FUNCTION>Pos</FUNCTION> positions output to a specified row and column coordinate; the first argument specifies the row, and
the second specifies the column. <FUNCTION>Pos</FUNCTION> can only be used in page mode.


</PARA>



<PARA>

<FUNCTION>Nl</FUNCTION> write a new line character to the output file; <FUNCTION>sp</FUNCTION> writes a space character to the output file; and <FUNCTION>qt</FUNCTION>
writes a quote character to the output file. Note that <LITERAL>\n</LITERAL> and <LITERAL>\'</LITERAL> can be used within string values to
represent the newline and double quote characters.


</PARA>



<PARA>

<FUNCTION>Newfile</FUNCTION> specifies the name of the report output file. Its first argument is the file's name; its second
argument is an append flag - if its value is non-zero the report appends to this file; if its value is zero
the report overwrites the contents of the file. <FUNCTION>Newfile</FUNCTION> can be called many times; this allows a single report program to generate many report output files during one execution. Programs are not required to
use <FUNCTION>newfile</FUNCTION>; if it is not used then <APPLICATION>LifeLines</APPLICATION> automatically asks for the name of the report output file.


</PARA>



<PARA>

<FUNCTION>Outfile</FUNCTION> returns the name of the current report output file.


</PARA>



<PARA>

<FUNCTION>Copyfile</FUNCTION> copies the contents of a file to the report output file; its argument is a string whose value is
the name of a file; if the file name is not absolute nor relative, then the <ENVAR>LLPROGRAMS</ENVAR> environment
variable, if set, will be used to search for the file; the file is opened and its contents copied to the report
output file.


</PARA>



<PARA>

<FUNCTION>Print</FUNCTION> prints its argument string to the standard output window; <FUNCTION>print</FUNCTION> may have one to 32 arguments.

</PARA>



</SECT1>



<SECT1>



<TITLE>

Person Set Functions and GEDCOM Extraction

</TITLE>

<GLOSSLIST><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>indiset</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>SET_V</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

declare a set variable

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>SET <FUNCTION>addtoset</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>SET</PARAMETER><PARAMETER>INDI</PARAMETER><PARAMETER>ANY</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

add a person to a set

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>SET <FUNCTION>deletefromset</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>SET</PARAMETER><PARAMETER>INDI</PARAMETER><PARAMETER>BOOL</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

remove a person from a set

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>INT <FUNCTION>lengthset</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>SET</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

size of a set

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>SET <FUNCTION>union</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>SET</PARAMETER><PARAMETER>SET</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

union of two sets

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>SET <FUNCTION>intersect</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>SET</PARAMETER><PARAMETER>SET</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

intersection of two sets

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>SET <FUNCTION>difference</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>SET</PARAMETER><PARAMETER>SET</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

difference of two sets

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>SET <FUNCTION>parentset</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>SET</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

set of all parents

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>SET <FUNCTION>childset</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>SET</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

set of all children

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>SET <FUNCTION>spouseset</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>SET</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

set of all spouses

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>SET <FUNCTION>siblingset</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>SET</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

set of all siblings

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>SET <FUNCTION>ancestorset</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>SET</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

set of all ancestors

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>SET <FUNCTION>descendentset</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>SET</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

set of all descendents

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>SET <FUNCTION>descendantset</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>SET</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

same as descendentset; spelling

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>SET <FUNCTION>uniqueset</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>SET</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

remove duplicates from set

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>namesort</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>SET</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

sort indiset by name

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>keysort</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>SET</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

sort indiset by key values

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>valuesort</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>SET</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

sort indiset by auxiliary values

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>genindiset</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>STRING</PARAMETER><PARAMETER>SET</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

generate indiset from GEDCOM name string

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>gengedcom</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>SET</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

generate GEDCOM file from person set

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><SYNOPSIS><COMMAND>forindiset</COMMAND> (<REPLACEABLE>SET</REPLACEABLE>, <REPLACEABLE>INDI_V</REPLACEABLE>, <REPLACEABLE>ANY_V</REPLACEABLE>, <REPLACEABLE>INT_V</REPLACEABLE>) { <REPLACEABLE>commands</REPLACEABLE> }</SYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

loop through all persons in person set

</PARA>

</GLOSSDEF></GLOSSENTRY></GLOSSLIST>

<PARA>

These functions allow you to manipulate person sets. A person set is a potentially large set of persons;
each person may have an arbitrary value associated with him/her. A person set must be declared with
the <FUNCTION>indiset</FUNCTION> function before it can be used.


</PARA>



<PARA>

<FUNCTION>Addtoset</FUNCTION> adds a person to a set. The first argument is the set; the second argument is the person; and
the third argument may be any value. The same person may be added to a set more than once, each time
with a different value. <FUNCTION>Deletefromset</FUNCTION> removes a person from a set. The first argument is the set; the
second argument is the person; if the third parameter is <RETURNVALUE>true</RETURNVALUE> all of the person's entries are removed
from the set; if <RETURNVALUE>false</RETURNVALUE> only the first entry is removed. <FUNCTION>Lengthset</FUNCTION> returns the number of persons in a
person set.


</PARA>



<PARA>

<FUNCTION>Union</FUNCTION>, <FUNCTION>intersect</FUNCTION> and <FUNCTION>difference</FUNCTION> return the set union, set intersection and set difference, respectively,
of two person sets. Each functions takes two person sets as arguments and returns a third person set. The
functions do not affect the values of their two argument sets.


</PARA>



<PARA>

<FUNCTION>Parentset</FUNCTION>, <FUNCTION>childset</FUNCTION>, <FUNCTION>spouseset</FUNCTION> and <FUNCTION>siblingset</FUNCTION> return the set of all parents, set of all children, set of
all spouses and set of all siblings, respectively, of the set of persons in their argument. In all cases there
is no change to the argument person set.


</PARA>



<PARA>

<FUNCTION>Ancestorset</FUNCTION> returns the set all ancestors of all persons in the argument set. <FUNCTION>Descendentset</FUNCTION> returns the
set of all descendents of all persons in the argument set. <FUNCTION>Descendantset</FUNCTION> is the same as <FUNCTION>descendentset</FUNCTION>; it allows an alternate spelling.

</PARA>



<PARA>

<FUNCTION>Uniqueset</FUNCTION> sorts a person set by key value and then removes all entries with duplicate keys; the input
set is modified and returned.


</PARA>



<PARA>

<FUNCTION>Namesort</FUNCTION>, <FUNCTION>keysort</FUNCTION> and <FUNCTION>valuesort</FUNCTION> sort a set of persons by name, by key and by associated value,
respectively.

</PARA>



<PARA>

Each person in a person set has an associated value. When a person is added to a set with <FUNCTION>addtoset</FUNCTION>, the
value is explicitly assigned. When new sets are created by other functions, a number of rules are used to
associate values with persons as they are added to the new sets. For <FUNCTION>parentset</FUNCTION>, <FUNCTION>childset</FUNCTION> and
<FUNCTION>spouseset</FUNCTION> the values are copied from the first input set person that causes the new person to be added
to the set. For <FUNCTION>union</FUNCTION>, <FUNCTION>intersect</FUNCTION> and <FUNCTION>difference</FUNCTION>, the values are copied from the values in the first input
set, except in the case of <FUNCTION>union</FUNCTION>, when persons are taken from the second set alone, in which case the
values come from there. For <FUNCTION>ancestorset</FUNCTION> and <FUNCTION>descendantset</FUNCTION> the value is set to the number of generations
the new person is away from the <EMPHASIS>first</EMPHASIS> person in the input set that the new person is related to. If the
new person is related to more than one person in the input set, the value is set for the nearest
relationship; that is, the value is as low as possible. <FUNCTION>Valuesort</FUNCTION> sorts a person set by the values of these
auxiliary values.

</PARA>



<PARA>

<FUNCTION>Genindiset</FUNCTION> generates the set of persons that matche a string whose value is a name in <ACRONYM>GEDCOM</ACRONYM>
format. <FUNCTION>Genindiset</FUNCTION> uses the same algorithm that matches names entered at the browse prompt or by
the user interaction <FUNCTION>getindiset</FUNCTION> function.


</PARA>



<PARA>

<FUNCTION>Gengedcom</FUNCTION> generates <ACRONYM>GEDCOM</ACRONYM> format output, to the report output file, of all persons in the argument
person set. The output contains a person record for each person in the set, and all the family records that
link at least two of the persons in the set together.


</PARA>



<PARA>

<FUNCTION>Forindiset</FUNCTION> is an iterator that loops through each person in an indiset. The first parameter is an indiset.
The second parameter is a variable that iterates through each person in the set. The third parameter
iterates through the values associated with the persons. The fourth parameter is an integer variable
that counts the iterations.

</PARA>



</SECT1>



<SECT1>



<TITLE>

Record Update Functions

</TITLE>

<GLOSSLIST><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>NODE <FUNCTION>createnode</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>STRING</PARAMETER><PARAMETER>STRING</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

create a GEDCOM node

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>addnode</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>NODE</PARAMETER><PARAMETER>NODE</PARAMETER><PARAMETER>NODE</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

add a node to a GEDCOM tree

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>deletenode</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>NODE</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

delete a node from a GEDCOM tree

</PARA>

</GLOSSDEF></GLOSSENTRY></GLOSSLIST>

<PARA>

These functions allow you to modify an internal <ACRONYM>GEDCOM</ACRONYM> node tree.


</PARA>



<PARA>

<FUNCTION>Createnode</FUNCTION> creates a <ACRONYM>GEDCOM</ACRONYM> node; the two arguments are tag and value strings, respectively; the
value string can be <RETURNVALUE>null</RETURNVALUE>. <FUNCTION>Addnode</FUNCTION> adds a node to a node tree. The first argument is the new node; the
second is the node in the tree that becomes the parent of the new node; the third is the node in the tree
that becomes the previous sibling of the new node; this argument is <RETURNVALUE>null</RETURNVALUE> if the new node is to become
the first child of the parent. <FUNCTION>Deletenode</FUNCTION> removes a node from a node tree.


</PARA>



<PARA>

These functions change the internal form of a node tree; they <EMPHASIS>do not</EMPHASIS> modify original records in the
database. These functions may be changed or extended in the future to allow database changes. Note:
<FUNCTION>deletenode</FUNCTION> has a memory leak.

</PARA>



</SECT1>



<SECT1>



<TITLE>

Record Linking Functions

</TITLE>

<GLOSSLIST><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>BOOL <FUNCTION>reference</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>STRING</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

determine if string is a cross reference

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>NODE <FUNCTION>dereference</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>STRING</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

reference cross reference or key to node tree

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>NODE <FUNCTION>getrecord</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>STRING</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

same as dereference

</PARA>

</GLOSSDEF></GLOSSENTRY></GLOSSLIST>

<PARA>

These functions allow you to recognize values that are cross references and to read the records they refer
to. <FUNCTION>Reference</FUNCTION> returns true if its string argument is a cross reference value, that is, the internal key of
one of the records in the database. <FUNCTION>Dereference</FUNCTION> returns the node tree of the record referred to by its cross
reference string argument. <FUNCTION>Getrecord</FUNCTION> is a synonym for <FUNCTION>dereference</FUNCTION>.

</PARA>



</SECT1>



<SECT1>



<TITLE>

Miscellaneous Functions

</TITLE>

<GLOSSLIST><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>lock</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INDI|FAM</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

lock a person or family in memory

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>unlock</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>INDI|FAM</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

unlock a person or family from memory

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>database</FUNCTION></FUNCDEF><VOID></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

return name of current database

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>version</FUNCTION></FUNCDEF><VOID></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

return version of <APPLICATION>LifeLines</APPLICATION> program

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>VOID <FUNCTION>system</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>STRING</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

execute string as a UNIX shell command

</PARA>

</GLOSSDEF></GLOSSENTRY><GLOSSENTRY><GLOSSTERM><FUNCSYNOPSIS><FUNCDEF>STRING <FUNCTION>getproperty</FUNCTION></FUNCDEF><PARAMDEF><PARAMETER>STRING</PARAMETER></PARAMDEF></FUNCSYNOPSIS></GLOSSTERM><GLOSSDEF>

<PARA>

extract system or user property.  Function available after v3.0.5.

</PARA>

</GLOSSDEF></GLOSSENTRY></GLOSSLIST>

<PARA>

<FUNCTION>Lock</FUNCTION> and <FUNCTION>unlock</FUNCTION> are used to lock a person or family into <ACRONYM>RAM</ACRONYM> memory, and to unlock a person or family
from <ACRONYM>RAM</ACRONYM> memory, respectively.


</PARA>



<PARA>

<FUNCTION>Database</FUNCTION> returns the name of the current database, useful in titling reports. <FUNCTION>Version</FUNCTION> returns the
version of the running <APPLICATION>LifeLines</APPLICATION> program, eg, <LITERAL>&llversion</LITERAL>.


</PARA>



<PARA>

<FUNCTION>System</FUNCTION> executes its string argument as a <ACRONYM>UNIX</ACRONYM> shell command by calling the <ACRONYM>UNIX</ACRONYM> system system
call.

</PARA>


<PARA>

The <FUNCTION>getproperty</FUNCTION> function extracts system or user
properties.  Properties are named group.subgroup.property or
group.property.  The following keys are available at the moment:
</PARA>

      <GLOSSLIST>

	<GLOSSENTRY>
	  <GLOSSTERM><OPTION>user.fullname</OPTION></GLOSSTERM>
	  <GLOSSDEF><PARA>
	    The full name of the current user.  This is fetched from the
	    system when possible.
	  </PARA></GLOSSDEF>
	</GLOSSENTRY>

	<GLOSSENTRY>
	  <GLOSSTERM><OPTION>user.email</OPTION></GLOSSTERM>
	  <GLOSSDEF><PARA>
	    The email address of the current user.  This is fetched
	    from the system when possible.
	  </PARA></GLOSSDEF>
	</GLOSSENTRY>
  
	<GLOSSENTRY>
	  <GLOSSTERM><OPTION>user.address</OPTION></GLOSSTERM>
	  <GLOSSDEF><PARA>
	    Postal address of the current user.
	  </PARA></GLOSSDEF>
	</GLOSSENTRY>
  
	<GLOSSENTRY>
	  <GLOSSTERM><OPTION>user.url</OPTION></GLOSSTERM>
	  <GLOSSDEF><PARA>
	    URL to the users home page.
	  </PARA></GLOSSDEF>
	</GLOSSENTRY>

      </GLOSSLIST>

      <PARA>
	These values can be changed by adding values to user options.
	[Miscellaneous utilities->Edit the user options file]
      </PARA>

</SECT1>

</CHAPTER></BOOK>
